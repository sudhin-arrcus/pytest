#
# ** Do not edit this file ** 
# This file was generated by the HAG
#

#R /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange ( ../macRange - ) 
# Generated for relative support for:
# ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range/macRange
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/macRange]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/macRange'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/macRange {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range/macRange
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kRequired
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  option -object_id \
    -cgetmethod _g_object_id -configuremethod _c_object_id -validatemethod _v_object_id \
    -default "" \
    -readonly false
  method _c_object_id {t v} {  }
  method _v_object_id {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_object_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -object_id }
  
  option -increment_by \
    -cgetmethod _g_increment_by -configuremethod _c_increment_by -validatemethod _v_increment_by \
    -default "" \
    -readonly false
  method _c_increment_by {t v} { $self _configure_basic $t $v }
  method _v_increment_by {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_increment_by {t} { $self _cget_basic $t }
  # multiplier 
  method _m_increment_by {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -increment_by }
  
  option -name \
    -cgetmethod _g_name -configuremethod _c_name -validatemethod _v_name \
    -default "" \
    -readonly false
  method _c_name {t v} { $self _configure_basic $t $v }
  method _v_name {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_name {t} { $self _cget_basic $t }
  # multiplier 
  method _m_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -name }
  
  option -count \
    -cgetmethod _g_count -configuremethod _c_count -validatemethod _v_count \
    -default "" \
    -readonly false
  method _c_count {t v} { $self _configure_basic $t $v }
  method _v_count {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_count {t} { $self _cget_basic $t }
  # multiplier 
  method _m_count {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -count }
  
  option -mac \
    -cgetmethod _g_mac -configuremethod _c_mac -validatemethod _v_mac \
    -default "" \
    -readonly false
  method _c_mac {t v} { $self _configure_basic $t $v }
  method _v_mac {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_mac {t} { $self _cget_basic $t }
  # multiplier 
  method _m_mac {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -mac }
  
  option -mtu \
    -cgetmethod _g_mtu -configuremethod _c_mtu -validatemethod _v_mtu \
    -default "" \
    -readonly false
  method _c_mtu {t v} { $self _configure_basic $t $v }
  method _v_mtu {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_mtu {t} { $self _cget_basic $t }
  # multiplier 
  method _m_mtu {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -mtu }
  
  option -enabled \
    -cgetmethod _g_enabled -configuremethod _c_enabled -validatemethod _v_enabled \
    -default "" \
    -readonly false
  method _c_enabled {t v} { $self _configure_basic $t $v }
  method _v_enabled {t v} { ::ixia::hag::ixn::validate::kBool $t $v }
  method _g_enabled {t} { $self _cget_kBool $t }
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
    -object_id objectId
    -increment_by incrementBy
    -name name
    -count count
    -mac mac
    -mtu mtu
    -enabled enabled
  }
  #
  variable MultiplierOptionGroups {
    _m_object_id {-object_id_format -object_id_base -object_id_incr}
    _m_increment_by {-increment_by_format -increment_by_base -increment_by_incr}
    _m_name {-name_format -name_base -name_incr}
    _m_count {-count_base -count_incr}
    _m_mac {-mac_format -mac_base -mac_incr}
    _m_mtu {-mtu_base -mtu_incr}
  }
}

#R /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange ( ../vlanRange - ) 
# Generated for relative support for:
# ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kRequired
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  option -inner_first_id \
    -cgetmethod _g_inner_first_id -configuremethod _c_inner_first_id -validatemethod _v_inner_first_id \
    -default "" \
    -readonly false
  method _c_inner_first_id {t v} { $self _configure_basic $t $v }
  method _v_inner_first_id {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_inner_first_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_inner_first_id {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -inner_first_id }
  
  option -inner_increment \
    -cgetmethod _g_inner_increment -configuremethod _c_inner_increment -validatemethod _v_inner_increment \
    -default "" \
    -readonly false
  method _c_inner_increment {t v} { $self _configure_basic $t $v }
  method _v_inner_increment {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_inner_increment {t} { $self _cget_basic $t }
  # multiplier 
  method _m_inner_increment {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -inner_increment }
  
  option -enabled \
    -cgetmethod _g_enabled -configuremethod _c_enabled -validatemethod _v_enabled \
    -default "" \
    -readonly false
  method _c_enabled {t v} { $self _configure_basic $t $v }
  method _v_enabled {t v} { ::ixia::hag::ixn::validate::kBool $t $v }
  method _g_enabled {t} { $self _cget_kBool $t }
  option -unique_count \
    -cgetmethod _g_unique_count -configuremethod _c_unique_count -validatemethod _v_unique_count \
    -default "" \
    -readonly false
  method _c_unique_count {t v} { $self _configure_basic $t $v }
  method _v_unique_count {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_unique_count {t} { $self _cget_basic $t }
  # multiplier 
  method _m_unique_count {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -unique_count }
  
  option -name \
    -cgetmethod _g_name -configuremethod _c_name -validatemethod _v_name \
    -default "" \
    -readonly false
  method _c_name {t v} { $self _configure_basic $t $v }
  method _v_name {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_name {t} { $self _cget_basic $t }
  # multiplier 
  method _m_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -name }
  
  option -increment_step \
    -cgetmethod _g_increment_step -configuremethod _c_increment_step -validatemethod _v_increment_step \
    -default "" \
    -readonly false
  method _c_increment_step {t v} { $self _configure_basic $t $v }
  method _v_increment_step {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_increment_step {t} { $self _cget_basic $t }
  # multiplier 
  method _m_increment_step {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -increment_step }
  
  option -tpid \
    -cgetmethod _g_tpid -configuremethod _c_tpid -validatemethod _v_tpid \
    -default "" \
    -readonly false
  method _c_tpid {t v} { $self _configure_basic $t $v }
  method _v_tpid {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_tpid {t} { $self _cget_basic $t }
  # multiplier 
  method _m_tpid {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tpid }
  
  option -priority \
    -cgetmethod _g_priority -configuremethod _c_priority -validatemethod _v_priority \
    -default "" \
    -readonly false
  method _c_priority {t v} { $self _configure_basic $t $v }
  method _v_priority {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_priority {t} { $self _cget_basic $t }
  # multiplier 
  method _m_priority {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -priority }
  
  option -inner_enable \
    -cgetmethod _g_inner_enable -configuremethod _c_inner_enable -validatemethod _v_inner_enable \
    -default "" \
    -readonly false
  method _c_inner_enable {t v} { $self _configure_basic $t $v }
  method _v_inner_enable {t v} { ::ixia::hag::ixn::validate::kBool $t $v }
  method _g_inner_enable {t} { $self _cget_kBool $t }
  option -object_id \
    -cgetmethod _g_object_id -configuremethod _c_object_id -validatemethod _v_object_id \
    -default "" \
    -readonly false
  method _c_object_id {t v} {  }
  method _v_object_id {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_object_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -object_id }
  
  option -inner_unique_count \
    -cgetmethod _g_inner_unique_count -configuremethod _c_inner_unique_count -validatemethod _v_inner_unique_count \
    -default "" \
    -readonly false
  method _c_inner_unique_count {t v} { $self _configure_basic $t $v }
  method _v_inner_unique_count {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_inner_unique_count {t} { $self _cget_basic $t }
  # multiplier 
  method _m_inner_unique_count {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -inner_unique_count }
  
  option -inner_tpid \
    -cgetmethod _g_inner_tpid -configuremethod _c_inner_tpid -validatemethod _v_inner_tpid \
    -default "" \
    -readonly false
  method _c_inner_tpid {t v} { $self _configure_basic $t $v }
  method _v_inner_tpid {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_inner_tpid {t} { $self _cget_basic $t }
  # multiplier 
  method _m_inner_tpid {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -inner_tpid }
  
  option -first_id \
    -cgetmethod _g_first_id -configuremethod _c_first_id -validatemethod _v_first_id \
    -default "" \
    -readonly false
  method _c_first_id {t v} { $self _configure_basic $t $v }
  method _v_first_id {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_first_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_first_id {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -first_id }
  
  option -increment \
    -cgetmethod _g_increment -configuremethod _c_increment -validatemethod _v_increment \
    -default "" \
    -readonly false
  method _c_increment {t v} { $self _configure_basic $t $v }
  method _v_increment {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_increment {t} { $self _cget_basic $t }
  # multiplier 
  method _m_increment {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -increment }
  
  option -inner_increment_step \
    -cgetmethod _g_inner_increment_step -configuremethod _c_inner_increment_step -validatemethod _v_inner_increment_step \
    -default "" \
    -readonly false
  method _c_inner_increment_step {t v} { $self _configure_basic $t $v }
  method _v_inner_increment_step {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_inner_increment_step {t} { $self _cget_basic $t }
  # multiplier 
  method _m_inner_increment_step {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -inner_increment_step }
  
  option -id_incr_mode \
    -cgetmethod _g_id_incr_mode -configuremethod _c_id_incr_mode -validatemethod _v_id_incr_mode \
    -default "" \
    -readonly false
  method _c_id_incr_mode {t v} { $self _configure_basic $t $v }
  method _v_id_incr_mode {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_id_incr_mode {t} { $self _cget_basic $t }
  # multiplier 
  method _m_id_incr_mode {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -id_incr_mode }
  
  option -inner_priority \
    -cgetmethod _g_inner_priority -configuremethod _c_inner_priority -validatemethod _v_inner_priority \
    -default "" \
    -readonly false
  method _c_inner_priority {t v} { $self _configure_basic $t $v }
  method _v_inner_priority {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_inner_priority {t} { $self _cget_basic $t }
  # multiplier 
  method _m_inner_priority {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -inner_priority }
  
  option -vlan_id_info \
    -cgetmethod _g_vlan_id_info -configuremethod _c_vlan_id_info -validatemethod _v_vlan_id_info \
    -default "" \
    -readonly false
  method _c_vlan_id_info {t v} { $self _configure_kList_as_list /vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange/vlanIdInfo $t $v }
  method _v_vlan_id_info {t v} { $self _validate_kList_as_list /vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange/vlanIdInfo $t $v }
  method _g_vlan_id_info {t} { $self _cget_basic $t }
  option -vlan_id_infomulti \
    -cgetmethod _g_vlan_id_infomulti -configuremethod _c_vlan_id_infomulti -validatemethod _v_vlan_id_infomulti \
    -default "" \
    -readonly false
  method _c_vlan_id_infomulti {t v} { $self _configure_kList_as_multiplier /vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange/vlanIdInfo $t $v }
  method _v_vlan_id_infomulti {t v} { $self _validate_kList_as_multiplier /vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange/vlanIdInfo $t $v }
  method _g_vlan_id_infomulti {t} { $self _cget_basic $t }
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
    -inner_first_id innerFirstId
    -inner_increment innerIncrement
    -enabled enabled
    -unique_count uniqueCount
    -name name
    -increment_step incrementStep
    -tpid tpid
    -priority priority
    -inner_enable innerEnable
    -object_id objectId
    -inner_unique_count innerUniqueCount
    -inner_tpid innerTpid
    -first_id firstId
    -increment increment
    -inner_increment_step innerIncrementStep
    -id_incr_mode idIncrMode
    -inner_priority innerPriority
  }
  #
  variable MultiplierOptionGroups {
    _m_inner_first_id {-inner_first_id_base -inner_first_id_incr}
    _m_inner_increment {-inner_increment_base -inner_increment_incr}
    _m_unique_count {-unique_count_base -unique_count_incr}
    _m_name {-name_format -name_base -name_incr}
    _m_increment_step {-increment_step_base -increment_step_incr}
    _m_tpid {-tpid_format -tpid_base -tpid_incr}
    _m_priority {-priority_base -priority_incr}
    _m_object_id {-object_id_format -object_id_base -object_id_incr}
    _m_inner_unique_count {-inner_unique_count_base -inner_unique_count_incr}
    _m_inner_tpid {-inner_tpid_format -inner_tpid_base -inner_tpid_incr}
    _m_first_id {-first_id_base -first_id_incr}
    _m_increment {-increment_base -increment_incr}
    _m_inner_increment_step {-inner_increment_step_base -inner_increment_step_incr}
    _m_id_incr_mode {-id_incr_mode_base -id_incr_mode_incr}
    _m_inner_priority {-inner_priority_base -inner_priority_incr}
  }
}

#? Children types for relative ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange 
#-->  "::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange/vlanIdInfo"..
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange/vlanIdInfo
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange/vlanIdInfo]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange/vlanIdInfo'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange/vlanIdInfo {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range/vlanRange/vlanIdInfo
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kList
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  option -object_id \
    -cgetmethod _g_object_id -configuremethod _c_object_id -validatemethod _v_object_id \
    -default "" \
    -readonly false
  method _c_object_id {t v} {  }
  method _v_object_id {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_object_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -object_id }
  
  option -unique_count \
    -cgetmethod _g_unique_count -configuremethod _c_unique_count -validatemethod _v_unique_count \
    -default "" \
    -readonly false
  method _c_unique_count {t v} { $self _configure_basic $t $v }
  method _v_unique_count {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_unique_count {t} { $self _cget_basic $t }
  # multiplier 
  method _m_unique_count {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -unique_count }
  
  option -tpid \
    -cgetmethod _g_tpid -configuremethod _c_tpid -validatemethod _v_tpid \
    -default "" \
    -readonly false
  method _c_tpid {t v} { $self _configure_basic $t $v }
  method _v_tpid {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_tpid {t} { $self _cget_basic $t }
  # multiplier 
  method _m_tpid {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tpid }
  
  option -increment \
    -cgetmethod _g_increment -configuremethod _c_increment -validatemethod _v_increment \
    -default "" \
    -readonly false
  method _c_increment {t v} { $self _configure_basic $t $v }
  method _v_increment {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_increment {t} { $self _cget_basic $t }
  # multiplier 
  method _m_increment {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -increment }
  
  option -increment_step \
    -cgetmethod _g_increment_step -configuremethod _c_increment_step -validatemethod _v_increment_step \
    -default "" \
    -readonly false
  method _c_increment_step {t v} { $self _configure_basic $t $v }
  method _v_increment_step {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_increment_step {t} { $self _cget_basic $t }
  # multiplier 
  method _m_increment_step {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -increment_step }
  
  option -first_id \
    -cgetmethod _g_first_id -configuremethod _c_first_id -validatemethod _v_first_id \
    -default "" \
    -readonly false
  method _c_first_id {t v} { $self _configure_basic $t $v }
  method _v_first_id {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_first_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_first_id {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -first_id }
  
  option -name \
    -cgetmethod _g_name -configuremethod _c_name -validatemethod _v_name \
    -default "" \
    -readonly false
  method _c_name {t v} { $self _configure_basic $t $v }
  method _v_name {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_name {t} { $self _cget_basic $t }
  # multiplier 
  method _m_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -name }
  
  option -priority \
    -cgetmethod _g_priority -configuremethod _c_priority -validatemethod _v_priority \
    -default "" \
    -readonly false
  method _c_priority {t v} { $self _configure_basic $t $v }
  method _v_priority {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_priority {t} { $self _cget_basic $t }
  # multiplier 
  method _m_priority {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -priority }
  
  option -enabled \
    -cgetmethod _g_enabled -configuremethod _c_enabled -validatemethod _v_enabled \
    -default "" \
    -readonly false
  method _c_enabled {t v} { $self _configure_basic $t $v }
  method _v_enabled {t v} { ::ixia::hag::ixn::validate::kBool $t $v }
  method _g_enabled {t} { $self _cget_kBool $t }
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
    -object_id objectId
    -unique_count uniqueCount
    -tpid tpid
    -increment increment
    -increment_step incrementStep
    -first_id firstId
    -name name
    -priority priority
    -enabled enabled
  }
  #
  variable MultiplierOptionGroups {
    _m_object_id {-object_id_format -object_id_base -object_id_incr}
    _m_unique_count {-unique_count_base -unique_count_incr}
    _m_tpid {-tpid_format -tpid_base -tpid_incr}
    _m_increment {-increment_base -increment_incr}
    _m_increment_step {-increment_step_base -increment_step_incr}
    _m_first_id {-first_id_base -first_id_incr}
    _m_name {-name_format -name_base -name_incr}
    _m_priority {-priority_base -priority_incr}
  }
}

#R End of relative type declaration(s)

#? Children for ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange 
#-->  "::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlv"..
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlv
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlv]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlv'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlv {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlv
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kList
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
  }
  #
  variable MultiplierOptionGroups {
  }
}

#? Children for ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange 
#-->  "::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlvQaz"..
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlvQaz
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlvQaz]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlvQaz'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlvQaz {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlvQaz
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kList
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
  }
  #
  variable MultiplierOptionGroups {
  }
}

#? Children for ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange 
#-->  "::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv"..
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {./tlvSettings - {} ./tlvSettings/lldpTlvSd - {} ./tlvSettings/lldpTlvPd - {} ./tlvSettings/lldpTlvSn - {} ./tlvSettings/lldpTlvOui - {} ./tlvSettings/lldpTlvMa - {} ./tlvSettings/lldpTlvCiscoNivCapable - {}}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kList
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  option -tlv_settings_object_id \
    -configuremethod _c_./tlvSettings/objectId \
    -cgetmethod _g_./tlvSettings/objectId \
    -readonly false
  method _c_./tlvSettings/objectId {t v} { $self _configure_relative ./tlvSettings -object_id $v }
  method _g_./tlvSettings/objectId {t} { $self _cget_relative ./tlvSettings -object_id }
  # multiplier 
  method _m_tlv_settings_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tlv_settings_object_id }
  
  option -tlv_settings_lldp_tlv_sd \
    -configuremethod _c_./tlvSettings/lldpTlvSd \
    -cgetmethod _g_./tlvSettings/lldpTlvSd \
    -readonly false
  method _c_./tlvSettings/lldpTlvSd {t v} { $self _configure_relative ./tlvSettings -lldp_tlv_sd $v }
  method _g_./tlvSettings/lldpTlvSd {t} { $self _cget_relative ./tlvSettings -lldp_tlv_sd }
  option -tlv_settings_lldp_tlv_pd \
    -configuremethod _c_./tlvSettings/lldpTlvPd \
    -cgetmethod _g_./tlvSettings/lldpTlvPd \
    -readonly false
  method _c_./tlvSettings/lldpTlvPd {t v} { $self _configure_relative ./tlvSettings -lldp_tlv_pd $v }
  method _g_./tlvSettings/lldpTlvPd {t} { $self _cget_relative ./tlvSettings -lldp_tlv_pd }
  option -tlv_settings_lldp_tlv_sn \
    -configuremethod _c_./tlvSettings/lldpTlvSn \
    -cgetmethod _g_./tlvSettings/lldpTlvSn \
    -readonly false
  method _c_./tlvSettings/lldpTlvSn {t v} { $self _configure_relative ./tlvSettings -lldp_tlv_sn $v }
  method _g_./tlvSettings/lldpTlvSn {t} { $self _cget_relative ./tlvSettings -lldp_tlv_sn }
  option -tlv_settings_lldp_tlv_oui \
    -configuremethod _c_./tlvSettings/lldpTlvOui \
    -cgetmethod _g_./tlvSettings/lldpTlvOui \
    -readonly false
  method _c_./tlvSettings/lldpTlvOui {t v} { $self _configure_relative ./tlvSettings -lldp_tlv_oui $v }
  method _g_./tlvSettings/lldpTlvOui {t} { $self _cget_relative ./tlvSettings -lldp_tlv_oui }
  option -tlv_settings_lldp_tlv_ma \
    -configuremethod _c_./tlvSettings/lldpTlvMa \
    -cgetmethod _g_./tlvSettings/lldpTlvMa \
    -readonly false
  method _c_./tlvSettings/lldpTlvMa {t v} { $self _configure_relative ./tlvSettings -lldp_tlv_ma $v }
  method _g_./tlvSettings/lldpTlvMa {t} { $self _cget_relative ./tlvSettings -lldp_tlv_ma }
  option -tlv_settings_lldp_tlv_cisco_niv_capable \
    -configuremethod _c_./tlvSettings/lldpTlvCiscoNivCapable \
    -cgetmethod _g_./tlvSettings/lldpTlvCiscoNivCapable \
    -readonly false
  method _c_./tlvSettings/lldpTlvCiscoNivCapable {t v} { $self _configure_relative ./tlvSettings -lldp_tlv_cisco_niv_capable $v }
  method _g_./tlvSettings/lldpTlvCiscoNivCapable {t} { $self _cget_relative ./tlvSettings -lldp_tlv_cisco_niv_capable }
  option -tlv_settings_lldp_tlv_sd_object_id \
    -configuremethod _c_./tlvSettings/lldpTlvSd/objectId \
    -cgetmethod _g_./tlvSettings/lldpTlvSd/objectId \
    -readonly false
  method _c_./tlvSettings/lldpTlvSd/objectId {t v} { $self _configure_relative ./tlvSettings/lldpTlvSd -object_id $v }
  method _g_./tlvSettings/lldpTlvSd/objectId {t} { $self _cget_relative ./tlvSettings/lldpTlvSd -object_id }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_sd_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_sd_object_id }
  
  option -tlv_settings_lldp_tlv_sd_description \
    -configuremethod _c_./tlvSettings/lldpTlvSd/description \
    -cgetmethod _g_./tlvSettings/lldpTlvSd/description \
    -readonly false
  method _c_./tlvSettings/lldpTlvSd/description {t v} { $self _configure_relative ./tlvSettings/lldpTlvSd -description $v }
  method _g_./tlvSettings/lldpTlvSd/description {t} { $self _cget_relative ./tlvSettings/lldpTlvSd -description }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_sd_description {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_sd_description }
  
  option -tlv_settings_lldp_tlv_pd_object_id \
    -configuremethod _c_./tlvSettings/lldpTlvPd/objectId \
    -cgetmethod _g_./tlvSettings/lldpTlvPd/objectId \
    -readonly false
  method _c_./tlvSettings/lldpTlvPd/objectId {t v} { $self _configure_relative ./tlvSettings/lldpTlvPd -object_id $v }
  method _g_./tlvSettings/lldpTlvPd/objectId {t} { $self _cget_relative ./tlvSettings/lldpTlvPd -object_id }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_pd_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_pd_object_id }
  
  option -tlv_settings_lldp_tlv_pd_description \
    -configuremethod _c_./tlvSettings/lldpTlvPd/description \
    -cgetmethod _g_./tlvSettings/lldpTlvPd/description \
    -readonly false
  method _c_./tlvSettings/lldpTlvPd/description {t v} { $self _configure_relative ./tlvSettings/lldpTlvPd -description $v }
  method _g_./tlvSettings/lldpTlvPd/description {t} { $self _cget_relative ./tlvSettings/lldpTlvPd -description }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_pd_description {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_pd_description }
  
  option -tlv_settings_lldp_tlv_sn_object_id \
    -configuremethod _c_./tlvSettings/lldpTlvSn/objectId \
    -cgetmethod _g_./tlvSettings/lldpTlvSn/objectId \
    -readonly false
  method _c_./tlvSettings/lldpTlvSn/objectId {t v} { $self _configure_relative ./tlvSettings/lldpTlvSn -object_id $v }
  method _g_./tlvSettings/lldpTlvSn/objectId {t} { $self _cget_relative ./tlvSettings/lldpTlvSn -object_id }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_sn_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_sn_object_id }
  
  option -tlv_settings_lldp_tlv_sn_description \
    -configuremethod _c_./tlvSettings/lldpTlvSn/description \
    -cgetmethod _g_./tlvSettings/lldpTlvSn/description \
    -readonly false
  method _c_./tlvSettings/lldpTlvSn/description {t v} { $self _configure_relative ./tlvSettings/lldpTlvSn -description $v }
  method _g_./tlvSettings/lldpTlvSn/description {t} { $self _cget_relative ./tlvSettings/lldpTlvSn -description }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_sn_description {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_sn_description }
  
  option -tlv_settings_lldp_tlv_oui_object_id \
    -configuremethod _c_./tlvSettings/lldpTlvOui/objectId \
    -cgetmethod _g_./tlvSettings/lldpTlvOui/objectId \
    -readonly false
  method _c_./tlvSettings/lldpTlvOui/objectId {t v} { $self _configure_relative ./tlvSettings/lldpTlvOui -object_id $v }
  method _g_./tlvSettings/lldpTlvOui/objectId {t} { $self _cget_relative ./tlvSettings/lldpTlvOui -object_id }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_oui_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_oui_object_id }
  
  option -tlv_settings_lldp_tlv_oui_info \
    -configuremethod _c_./tlvSettings/lldpTlvOui/info \
    -cgetmethod _g_./tlvSettings/lldpTlvOui/info \
    -readonly false
  method _c_./tlvSettings/lldpTlvOui/info {t v} { $self _configure_relative ./tlvSettings/lldpTlvOui -info $v }
  method _g_./tlvSettings/lldpTlvOui/info {t} { $self _cget_relative ./tlvSettings/lldpTlvOui -info }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_oui_info {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_oui_info }
  
  option -tlv_settings_lldp_tlv_oui_subtype \
    -configuremethod _c_./tlvSettings/lldpTlvOui/subtype \
    -cgetmethod _g_./tlvSettings/lldpTlvOui/subtype \
    -readonly false
  method _c_./tlvSettings/lldpTlvOui/subtype {t v} { $self _configure_relative ./tlvSettings/lldpTlvOui -subtype $v }
  method _g_./tlvSettings/lldpTlvOui/subtype {t} { $self _cget_relative ./tlvSettings/lldpTlvOui -subtype }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_oui_subtype {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_oui_subtype }
  
  option -tlv_settings_lldp_tlv_oui_oui \
    -configuremethod _c_./tlvSettings/lldpTlvOui/oui \
    -cgetmethod _g_./tlvSettings/lldpTlvOui/oui \
    -readonly false
  method _c_./tlvSettings/lldpTlvOui/oui {t v} { $self _configure_relative ./tlvSettings/lldpTlvOui -oui $v }
  method _g_./tlvSettings/lldpTlvOui/oui {t} { $self _cget_relative ./tlvSettings/lldpTlvOui -oui }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_oui_oui {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_oui_oui }
  
  option -tlv_settings_lldp_tlv_ma_object_id \
    -configuremethod _c_./tlvSettings/lldpTlvMa/objectId \
    -cgetmethod _g_./tlvSettings/lldpTlvMa/objectId \
    -readonly false
  method _c_./tlvSettings/lldpTlvMa/objectId {t v} { $self _configure_relative ./tlvSettings/lldpTlvMa -object_id $v }
  method _g_./tlvSettings/lldpTlvMa/objectId {t} { $self _cget_relative ./tlvSettings/lldpTlvMa -object_id }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_ma_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_ma_object_id }
  
  option -tlv_settings_lldp_tlv_ma_int_no \
    -configuremethod _c_./tlvSettings/lldpTlvMa/intNo \
    -cgetmethod _g_./tlvSettings/lldpTlvMa/intNo \
    -readonly false
  method _c_./tlvSettings/lldpTlvMa/intNo {t v} { $self _configure_relative ./tlvSettings/lldpTlvMa -int_no $v }
  method _g_./tlvSettings/lldpTlvMa/intNo {t} { $self _cget_relative ./tlvSettings/lldpTlvMa -int_no }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_ma_int_no {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_ma_int_no }
  
  option -tlv_settings_lldp_tlv_ma_address \
    -configuremethod _c_./tlvSettings/lldpTlvMa/address \
    -cgetmethod _g_./tlvSettings/lldpTlvMa/address \
    -readonly false
  method _c_./tlvSettings/lldpTlvMa/address {t v} { $self _configure_relative ./tlvSettings/lldpTlvMa -address $v }
  method _g_./tlvSettings/lldpTlvMa/address {t} { $self _cget_relative ./tlvSettings/lldpTlvMa -address }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_ma_address {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_ma_address }
  
  option -tlv_settings_lldp_tlv_ma_int_subtype \
    -configuremethod _c_./tlvSettings/lldpTlvMa/intSubtype \
    -cgetmethod _g_./tlvSettings/lldpTlvMa/intSubtype \
    -readonly false
  method _c_./tlvSettings/lldpTlvMa/intSubtype {t v} { $self _configure_relative ./tlvSettings/lldpTlvMa -int_subtype $v }
  method _g_./tlvSettings/lldpTlvMa/intSubtype {t} { $self _cget_relative ./tlvSettings/lldpTlvMa -int_subtype }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_ma_int_subtype {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_ma_int_subtype }
  
  option -tlv_settings_lldp_tlv_cisco_niv_capable_object_id \
    -configuremethod _c_./tlvSettings/lldpTlvCiscoNivCapable/objectId \
    -cgetmethod _g_./tlvSettings/lldpTlvCiscoNivCapable/objectId \
    -readonly false
  method _c_./tlvSettings/lldpTlvCiscoNivCapable/objectId {t v} { $self _configure_relative ./tlvSettings/lldpTlvCiscoNivCapable -object_id $v }
  method _g_./tlvSettings/lldpTlvCiscoNivCapable/objectId {t} { $self _cget_relative ./tlvSettings/lldpTlvCiscoNivCapable -object_id }
  # multiplier 
  method _m_tlv_settings_lldp_tlv_cisco_niv_capable_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -tlv_settings_lldp_tlv_cisco_niv_capable_object_id }
  
  option -object_id \
    -cgetmethod _g_object_id -configuremethod _c_object_id -validatemethod _v_object_id \
    -default "" \
    -readonly false
  method _c_object_id {t v} {  }
  method _v_object_id {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_object_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -object_id }
  
  option -name \
    -cgetmethod _g_name -configuremethod _c_name -validatemethod _v_name \
    -default "" \
    -readonly false
  method _c_name {t v} { $self _configure_basic $t $v }
  method _v_name {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_name {t} { $self _cget_basic $t }
  # multiplier 
  method _m_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -name }
  
  option -type \
    -cgetmethod _g_type -configuremethod _c_type -validatemethod _v_type \
    -default "" \
    -readonly false
  method _c_type {t v} { $self _configure_basic $t $v }
  method _v_type {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_type {t} { $self _cget_basic $t }
  # multiplier 
  method _m_type {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -type }
  
  option -enabled \
    -cgetmethod _g_enabled -configuremethod _c_enabled -validatemethod _v_enabled \
    -default "" \
    -readonly false
  method _c_enabled {t v} { $self _configure_basic $t $v }
  method _v_enabled {t v} { ::ixia::hag::ixn::validate::kBool $t $v }
  method _g_enabled {t} { $self _cget_kBool $t }
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
    -tlv_settings_object_id ./tlvSettings/objectId
    -tlv_settings_lldp_tlv_sd ./tlvSettings/lldpTlvSd
    -tlv_settings_lldp_tlv_pd ./tlvSettings/lldpTlvPd
    -tlv_settings_lldp_tlv_sn ./tlvSettings/lldpTlvSn
    -tlv_settings_lldp_tlv_oui ./tlvSettings/lldpTlvOui
    -tlv_settings_lldp_tlv_ma ./tlvSettings/lldpTlvMa
    -tlv_settings_lldp_tlv_cisco_niv_capable ./tlvSettings/lldpTlvCiscoNivCapable
    -tlv_settings_lldp_tlv_sd_object_id ./tlvSettings/lldpTlvSd/objectId
    -tlv_settings_lldp_tlv_sd_description ./tlvSettings/lldpTlvSd/description
    -tlv_settings_lldp_tlv_pd_object_id ./tlvSettings/lldpTlvPd/objectId
    -tlv_settings_lldp_tlv_pd_description ./tlvSettings/lldpTlvPd/description
    -tlv_settings_lldp_tlv_sn_object_id ./tlvSettings/lldpTlvSn/objectId
    -tlv_settings_lldp_tlv_sn_description ./tlvSettings/lldpTlvSn/description
    -tlv_settings_lldp_tlv_oui_object_id ./tlvSettings/lldpTlvOui/objectId
    -tlv_settings_lldp_tlv_oui_info ./tlvSettings/lldpTlvOui/info
    -tlv_settings_lldp_tlv_oui_subtype ./tlvSettings/lldpTlvOui/subtype
    -tlv_settings_lldp_tlv_oui_oui ./tlvSettings/lldpTlvOui/oui
    -tlv_settings_lldp_tlv_ma_object_id ./tlvSettings/lldpTlvMa/objectId
    -tlv_settings_lldp_tlv_ma_int_no ./tlvSettings/lldpTlvMa/intNo
    -tlv_settings_lldp_tlv_ma_address ./tlvSettings/lldpTlvMa/address
    -tlv_settings_lldp_tlv_ma_int_subtype ./tlvSettings/lldpTlvMa/intSubtype
    -tlv_settings_lldp_tlv_cisco_niv_capable_object_id ./tlvSettings/lldpTlvCiscoNivCapable/objectId
    -object_id objectId
    -name name
    -type type
    -enabled enabled
  }
  #
  variable MultiplierOptionGroups {
    _m_tlv_settings_object_id {-tlv_settings_object_id_format -tlv_settings_object_id_base -tlv_settings_object_id_incr}
    _m_tlv_settings_lldp_tlv_sd_object_id {-tlv_settings_lldp_tlv_sd_object_id_format -tlv_settings_lldp_tlv_sd_object_id_base -tlv_settings_lldp_tlv_sd_object_id_incr}
    _m_tlv_settings_lldp_tlv_sd_description {-tlv_settings_lldp_tlv_sd_description_format -tlv_settings_lldp_tlv_sd_description_base -tlv_settings_lldp_tlv_sd_description_incr}
    _m_tlv_settings_lldp_tlv_pd_object_id {-tlv_settings_lldp_tlv_pd_object_id_format -tlv_settings_lldp_tlv_pd_object_id_base -tlv_settings_lldp_tlv_pd_object_id_incr}
    _m_tlv_settings_lldp_tlv_pd_description {-tlv_settings_lldp_tlv_pd_description_format -tlv_settings_lldp_tlv_pd_description_base -tlv_settings_lldp_tlv_pd_description_incr}
    _m_tlv_settings_lldp_tlv_sn_object_id {-tlv_settings_lldp_tlv_sn_object_id_format -tlv_settings_lldp_tlv_sn_object_id_base -tlv_settings_lldp_tlv_sn_object_id_incr}
    _m_tlv_settings_lldp_tlv_sn_description {-tlv_settings_lldp_tlv_sn_description_format -tlv_settings_lldp_tlv_sn_description_base -tlv_settings_lldp_tlv_sn_description_incr}
    _m_tlv_settings_lldp_tlv_oui_object_id {-tlv_settings_lldp_tlv_oui_object_id_format -tlv_settings_lldp_tlv_oui_object_id_base -tlv_settings_lldp_tlv_oui_object_id_incr}
    _m_tlv_settings_lldp_tlv_oui_info {-tlv_settings_lldp_tlv_oui_info_format -tlv_settings_lldp_tlv_oui_info_base -tlv_settings_lldp_tlv_oui_info_incr}
    _m_tlv_settings_lldp_tlv_oui_subtype {-tlv_settings_lldp_tlv_oui_subtype_base -tlv_settings_lldp_tlv_oui_subtype_incr}
    _m_tlv_settings_lldp_tlv_oui_oui {-tlv_settings_lldp_tlv_oui_oui_format -tlv_settings_lldp_tlv_oui_oui_base -tlv_settings_lldp_tlv_oui_oui_incr}
    _m_tlv_settings_lldp_tlv_ma_object_id {-tlv_settings_lldp_tlv_ma_object_id_format -tlv_settings_lldp_tlv_ma_object_id_base -tlv_settings_lldp_tlv_ma_object_id_incr}
    _m_tlv_settings_lldp_tlv_ma_int_no {-tlv_settings_lldp_tlv_ma_int_no_base -tlv_settings_lldp_tlv_ma_int_no_incr}
    _m_tlv_settings_lldp_tlv_ma_address {-tlv_settings_lldp_tlv_ma_address_format -tlv_settings_lldp_tlv_ma_address_base -tlv_settings_lldp_tlv_ma_address_incr}
    _m_tlv_settings_lldp_tlv_ma_int_subtype {-tlv_settings_lldp_tlv_ma_int_subtype_format -tlv_settings_lldp_tlv_ma_int_subtype_base -tlv_settings_lldp_tlv_ma_int_subtype_incr}
    _m_tlv_settings_lldp_tlv_cisco_niv_capable_object_id {-tlv_settings_lldp_tlv_cisco_niv_capable_object_id_format -tlv_settings_lldp_tlv_cisco_niv_capable_object_id_base -tlv_settings_lldp_tlv_cisco_niv_capable_object_id_incr}
    _m_object_id {-object_id_format -object_id_base -object_id_incr}
    _m_name {-name_format -name_base -name_incr}
    _m_type {-type_base -type_incr}
  }
}

#? Children for ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange 
#-->  "::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings"..
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kRequired
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  option -lldp_tlv_sd_object_id \
    -configuremethod _c_./lldpTlvSd/objectId \
    -cgetmethod _g_./lldpTlvSd/objectId \
    -readonly false
  method _c_./lldpTlvSd/objectId {t v} { $self _configure_relative ./lldpTlvSd -object_id $v }
  method _g_./lldpTlvSd/objectId {t} { $self _cget_relative ./lldpTlvSd -object_id }
  # multiplier 
  method _m_lldp_tlv_sd_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -lldp_tlv_sd_object_id }
  
  option -lldp_tlv_sd_description \
    -configuremethod _c_./lldpTlvSd/description \
    -cgetmethod _g_./lldpTlvSd/description \
    -readonly false
  method _c_./lldpTlvSd/description {t v} { $self _configure_relative ./lldpTlvSd -description $v }
  method _g_./lldpTlvSd/description {t} { $self _cget_relative ./lldpTlvSd -description }
  # multiplier 
  method _m_lldp_tlv_sd_description {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -lldp_tlv_sd_description }
  
  option -lldp_tlv_pd_object_id \
    -configuremethod _c_./lldpTlvPd/objectId \
    -cgetmethod _g_./lldpTlvPd/objectId \
    -readonly false
  method _c_./lldpTlvPd/objectId {t v} { $self _configure_relative ./lldpTlvPd -object_id $v }
  method _g_./lldpTlvPd/objectId {t} { $self _cget_relative ./lldpTlvPd -object_id }
  # multiplier 
  method _m_lldp_tlv_pd_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -lldp_tlv_pd_object_id }
  
  option -lldp_tlv_pd_description \
    -configuremethod _c_./lldpTlvPd/description \
    -cgetmethod _g_./lldpTlvPd/description \
    -readonly false
  method _c_./lldpTlvPd/description {t v} { $self _configure_relative ./lldpTlvPd -description $v }
  method _g_./lldpTlvPd/description {t} { $self _cget_relative ./lldpTlvPd -description }
  # multiplier 
  method _m_lldp_tlv_pd_description {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -lldp_tlv_pd_description }
  
  option -lldp_tlv_sn_object_id \
    -configuremethod _c_./lldpTlvSn/objectId \
    -cgetmethod _g_./lldpTlvSn/objectId \
    -readonly false
  method _c_./lldpTlvSn/objectId {t v} { $self _configure_relative ./lldpTlvSn -object_id $v }
  method _g_./lldpTlvSn/objectId {t} { $self _cget_relative ./lldpTlvSn -object_id }
  # multiplier 
  method _m_lldp_tlv_sn_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -lldp_tlv_sn_object_id }
  
  option -lldp_tlv_sn_description \
    -configuremethod _c_./lldpTlvSn/description \
    -cgetmethod _g_./lldpTlvSn/description \
    -readonly false
  method _c_./lldpTlvSn/description {t v} { $self _configure_relative ./lldpTlvSn -description $v }
  method _g_./lldpTlvSn/description {t} { $self _cget_relative ./lldpTlvSn -description }
  # multiplier 
  method _m_lldp_tlv_sn_description {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -lldp_tlv_sn_description }
  
  option -lldp_tlv_oui_object_id \
    -configuremethod _c_./lldpTlvOui/objectId \
    -cgetmethod _g_./lldpTlvOui/objectId \
    -readonly false
  method _c_./lldpTlvOui/objectId {t v} { $self _configure_relative ./lldpTlvOui -object_id $v }
  method _g_./lldpTlvOui/objectId {t} { $self _cget_relative ./lldpTlvOui -object_id }
  # multiplier 
  method _m_lldp_tlv_oui_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -lldp_tlv_oui_object_id }
  
  option -lldp_tlv_oui_info \
    -configuremethod _c_./lldpTlvOui/info \
    -cgetmethod _g_./lldpTlvOui/info \
    -readonly false
  method _c_./lldpTlvOui/info {t v} { $self _configure_relative ./lldpTlvOui -info $v }
  method _g_./lldpTlvOui/info {t} { $self _cget_relative ./lldpTlvOui -info }
  # multiplier 
  method _m_lldp_tlv_oui_info {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -lldp_tlv_oui_info }
  
  option -lldp_tlv_oui_subtype \
    -configuremethod _c_./lldpTlvOui/subtype \
    -cgetmethod _g_./lldpTlvOui/subtype \
    -readonly false
  method _c_./lldpTlvOui/subtype {t v} { $self _configure_relative ./lldpTlvOui -subtype $v }
  method _g_./lldpTlvOui/subtype {t} { $self _cget_relative ./lldpTlvOui -subtype }
  # multiplier 
  method _m_lldp_tlv_oui_subtype {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -lldp_tlv_oui_subtype }
  
  option -lldp_tlv_oui_oui \
    -configuremethod _c_./lldpTlvOui/oui \
    -cgetmethod _g_./lldpTlvOui/oui \
    -readonly false
  method _c_./lldpTlvOui/oui {t v} { $self _configure_relative ./lldpTlvOui -oui $v }
  method _g_./lldpTlvOui/oui {t} { $self _cget_relative ./lldpTlvOui -oui }
  # multiplier 
  method _m_lldp_tlv_oui_oui {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -lldp_tlv_oui_oui }
  
  option -lldp_tlv_ma_object_id \
    -configuremethod _c_./lldpTlvMa/objectId \
    -cgetmethod _g_./lldpTlvMa/objectId \
    -readonly false
  method _c_./lldpTlvMa/objectId {t v} { $self _configure_relative ./lldpTlvMa -object_id $v }
  method _g_./lldpTlvMa/objectId {t} { $self _cget_relative ./lldpTlvMa -object_id }
  # multiplier 
  method _m_lldp_tlv_ma_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -lldp_tlv_ma_object_id }
  
  option -lldp_tlv_ma_int_no \
    -configuremethod _c_./lldpTlvMa/intNo \
    -cgetmethod _g_./lldpTlvMa/intNo \
    -readonly false
  method _c_./lldpTlvMa/intNo {t v} { $self _configure_relative ./lldpTlvMa -int_no $v }
  method _g_./lldpTlvMa/intNo {t} { $self _cget_relative ./lldpTlvMa -int_no }
  # multiplier 
  method _m_lldp_tlv_ma_int_no {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -lldp_tlv_ma_int_no }
  
  option -lldp_tlv_ma_address \
    -configuremethod _c_./lldpTlvMa/address \
    -cgetmethod _g_./lldpTlvMa/address \
    -readonly false
  method _c_./lldpTlvMa/address {t v} { $self _configure_relative ./lldpTlvMa -address $v }
  method _g_./lldpTlvMa/address {t} { $self _cget_relative ./lldpTlvMa -address }
  # multiplier 
  method _m_lldp_tlv_ma_address {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -lldp_tlv_ma_address }
  
  option -lldp_tlv_ma_int_subtype \
    -configuremethod _c_./lldpTlvMa/intSubtype \
    -cgetmethod _g_./lldpTlvMa/intSubtype \
    -readonly false
  method _c_./lldpTlvMa/intSubtype {t v} { $self _configure_relative ./lldpTlvMa -int_subtype $v }
  method _g_./lldpTlvMa/intSubtype {t} { $self _cget_relative ./lldpTlvMa -int_subtype }
  # multiplier 
  method _m_lldp_tlv_ma_int_subtype {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -lldp_tlv_ma_int_subtype }
  
  option -lldp_tlv_cisco_niv_capable_object_id \
    -configuremethod _c_./lldpTlvCiscoNivCapable/objectId \
    -cgetmethod _g_./lldpTlvCiscoNivCapable/objectId \
    -readonly false
  method _c_./lldpTlvCiscoNivCapable/objectId {t v} { $self _configure_relative ./lldpTlvCiscoNivCapable -object_id $v }
  method _g_./lldpTlvCiscoNivCapable/objectId {t} { $self _cget_relative ./lldpTlvCiscoNivCapable -object_id }
  # multiplier 
  method _m_lldp_tlv_cisco_niv_capable_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -lldp_tlv_cisco_niv_capable_object_id }
  
  option -object_id \
    -cgetmethod _g_object_id -configuremethod _c_object_id -validatemethod _v_object_id \
    -default "" \
    -readonly false
  method _c_object_id {t v} {  }
  method _v_object_id {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_object_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -object_id }
  
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
    -lldp_tlv_sd_object_id ./lldpTlvSd/objectId
    -lldp_tlv_sd_description ./lldpTlvSd/description
    -lldp_tlv_pd_object_id ./lldpTlvPd/objectId
    -lldp_tlv_pd_description ./lldpTlvPd/description
    -lldp_tlv_sn_object_id ./lldpTlvSn/objectId
    -lldp_tlv_sn_description ./lldpTlvSn/description
    -lldp_tlv_oui_object_id ./lldpTlvOui/objectId
    -lldp_tlv_oui_info ./lldpTlvOui/info
    -lldp_tlv_oui_subtype ./lldpTlvOui/subtype
    -lldp_tlv_oui_oui ./lldpTlvOui/oui
    -lldp_tlv_ma_object_id ./lldpTlvMa/objectId
    -lldp_tlv_ma_int_no ./lldpTlvMa/intNo
    -lldp_tlv_ma_address ./lldpTlvMa/address
    -lldp_tlv_ma_int_subtype ./lldpTlvMa/intSubtype
    -lldp_tlv_cisco_niv_capable_object_id ./lldpTlvCiscoNivCapable/objectId
    -object_id objectId
  }
  #
  variable MultiplierOptionGroups {
    _m_lldp_tlv_sd_object_id {-lldp_tlv_sd_object_id_format -lldp_tlv_sd_object_id_base -lldp_tlv_sd_object_id_incr}
    _m_lldp_tlv_sd_description {-lldp_tlv_sd_description_format -lldp_tlv_sd_description_base -lldp_tlv_sd_description_incr}
    _m_lldp_tlv_pd_object_id {-lldp_tlv_pd_object_id_format -lldp_tlv_pd_object_id_base -lldp_tlv_pd_object_id_incr}
    _m_lldp_tlv_pd_description {-lldp_tlv_pd_description_format -lldp_tlv_pd_description_base -lldp_tlv_pd_description_incr}
    _m_lldp_tlv_sn_object_id {-lldp_tlv_sn_object_id_format -lldp_tlv_sn_object_id_base -lldp_tlv_sn_object_id_incr}
    _m_lldp_tlv_sn_description {-lldp_tlv_sn_description_format -lldp_tlv_sn_description_base -lldp_tlv_sn_description_incr}
    _m_lldp_tlv_oui_object_id {-lldp_tlv_oui_object_id_format -lldp_tlv_oui_object_id_base -lldp_tlv_oui_object_id_incr}
    _m_lldp_tlv_oui_info {-lldp_tlv_oui_info_format -lldp_tlv_oui_info_base -lldp_tlv_oui_info_incr}
    _m_lldp_tlv_oui_subtype {-lldp_tlv_oui_subtype_base -lldp_tlv_oui_subtype_incr}
    _m_lldp_tlv_oui_oui {-lldp_tlv_oui_oui_format -lldp_tlv_oui_oui_base -lldp_tlv_oui_oui_incr}
    _m_lldp_tlv_ma_object_id {-lldp_tlv_ma_object_id_format -lldp_tlv_ma_object_id_base -lldp_tlv_ma_object_id_incr}
    _m_lldp_tlv_ma_int_no {-lldp_tlv_ma_int_no_base -lldp_tlv_ma_int_no_incr}
    _m_lldp_tlv_ma_address {-lldp_tlv_ma_address_format -lldp_tlv_ma_address_base -lldp_tlv_ma_address_incr}
    _m_lldp_tlv_ma_int_subtype {-lldp_tlv_ma_int_subtype_format -lldp_tlv_ma_int_subtype_base -lldp_tlv_ma_int_subtype_incr}
    _m_lldp_tlv_cisco_niv_capable_object_id {-lldp_tlv_cisco_niv_capable_object_id_format -lldp_tlv_cisco_niv_capable_object_id_base -lldp_tlv_cisco_niv_capable_object_id_incr}
    _m_object_id {-object_id_format -object_id_base -object_id_incr}
  }
}

#? Children for ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange 
#-->  "::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvCiscoNivCapable"..
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvCiscoNivCapable
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvCiscoNivCapable]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvCiscoNivCapable'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvCiscoNivCapable {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvCiscoNivCapable
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kRequired
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  option -object_id \
    -cgetmethod _g_object_id -configuremethod _c_object_id -validatemethod _v_object_id \
    -default "" \
    -readonly false
  method _c_object_id {t v} {  }
  method _v_object_id {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_object_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -object_id }
  
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
    -object_id objectId
  }
  #
  variable MultiplierOptionGroups {
    _m_object_id {-object_id_format -object_id_base -object_id_incr}
  }
}

#? Children for ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange 
#-->  "::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvMa"..
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvMa
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvMa]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvMa'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvMa {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvMa
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kRequired
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  option -object_id \
    -cgetmethod _g_object_id -configuremethod _c_object_id -validatemethod _v_object_id \
    -default "" \
    -readonly false
  method _c_object_id {t v} {  }
  method _v_object_id {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_object_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -object_id }
  
  option -int_no \
    -cgetmethod _g_int_no -configuremethod _c_int_no -validatemethod _v_int_no \
    -default "" \
    -readonly false
  method _c_int_no {t v} { $self _configure_basic $t $v }
  method _v_int_no {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_int_no {t} { $self _cget_basic $t }
  # multiplier 
  method _m_int_no {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -int_no }
  
  option -address \
    -cgetmethod _g_address -configuremethod _c_address -validatemethod _v_address \
    -default "" \
    -readonly false
  method _c_address {t v} { $self _configure_basic $t $v }
  method _v_address {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_address {t} { $self _cget_basic $t }
  # multiplier 
  method _m_address {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -address }
  
  option -int_subtype \
    -cgetmethod _g_int_subtype -configuremethod _c_int_subtype -validatemethod _v_int_subtype \
    -default "" \
    -readonly false
  method _c_int_subtype {t v} { $self _configure_basic $t $v }
  method _v_int_subtype {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_int_subtype {t} { $self _cget_basic $t }
  # multiplier 
  method _m_int_subtype {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -int_subtype }
  
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
    -object_id objectId
    -int_no intNo
    -address address
    -int_subtype intSubtype
  }
  #
  variable MultiplierOptionGroups {
    _m_object_id {-object_id_format -object_id_base -object_id_incr}
    _m_int_no {-int_no_base -int_no_incr}
    _m_address {-address_format -address_base -address_incr}
    _m_int_subtype {-int_subtype_format -int_subtype_base -int_subtype_incr}
  }
}

#? Children for ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange 
#-->  "::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvOui"..
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvOui
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvOui]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvOui'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvOui {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvOui
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kRequired
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  option -object_id \
    -cgetmethod _g_object_id -configuremethod _c_object_id -validatemethod _v_object_id \
    -default "" \
    -readonly false
  method _c_object_id {t v} {  }
  method _v_object_id {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_object_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -object_id }
  
  option -info \
    -cgetmethod _g_info -configuremethod _c_info -validatemethod _v_info \
    -default "" \
    -readonly false
  method _c_info {t v} { $self _configure_basic $t $v }
  method _v_info {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_info {t} { $self _cget_basic $t }
  # multiplier 
  method _m_info {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -info }
  
  option -subtype \
    -cgetmethod _g_subtype -configuremethod _c_subtype -validatemethod _v_subtype \
    -default "" \
    -readonly false
  method _c_subtype {t v} { $self _configure_basic $t $v }
  method _v_subtype {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_subtype {t} { $self _cget_basic $t }
  # multiplier 
  method _m_subtype {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -subtype }
  
  option -oui \
    -cgetmethod _g_oui -configuremethod _c_oui -validatemethod _v_oui \
    -default "" \
    -readonly false
  method _c_oui {t v} { $self _configure_basic $t $v }
  method _v_oui {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_oui {t} { $self _cget_basic $t }
  # multiplier 
  method _m_oui {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -oui }
  
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
    -object_id objectId
    -info info
    -subtype subtype
    -oui oui
  }
  #
  variable MultiplierOptionGroups {
    _m_object_id {-object_id_format -object_id_base -object_id_incr}
    _m_info {-info_format -info_base -info_incr}
    _m_subtype {-subtype_base -subtype_incr}
    _m_oui {-oui_format -oui_base -oui_incr}
  }
}

#? Children for ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange 
#-->  "::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvPd"..
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvPd
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvPd]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvPd'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvPd {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvPd
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kRequired
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  option -object_id \
    -cgetmethod _g_object_id -configuremethod _c_object_id -validatemethod _v_object_id \
    -default "" \
    -readonly false
  method _c_object_id {t v} {  }
  method _v_object_id {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_object_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -object_id }
  
  option -description \
    -cgetmethod _g_description -configuremethod _c_description -validatemethod _v_description \
    -default "" \
    -readonly false
  method _c_description {t v} { $self _configure_basic $t $v }
  method _v_description {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_description {t} { $self _cget_basic $t }
  # multiplier 
  method _m_description {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -description }
  
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
    -object_id objectId
    -description description
  }
  #
  variable MultiplierOptionGroups {
    _m_object_id {-object_id_format -object_id_base -object_id_incr}
    _m_description {-description_format -description_base -description_incr}
  }
}

#? Children for ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange 
#-->  "::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvSd"..
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvSd
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvSd]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvSd'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvSd {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvSd
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kRequired
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  option -object_id \
    -cgetmethod _g_object_id -configuremethod _c_object_id -validatemethod _v_object_id \
    -default "" \
    -readonly false
  method _c_object_id {t v} {  }
  method _v_object_id {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_object_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -object_id }
  
  option -description \
    -cgetmethod _g_description -configuremethod _c_description -validatemethod _v_description \
    -default "" \
    -readonly false
  method _c_description {t v} { $self _configure_basic $t $v }
  method _v_description {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_description {t} { $self _cget_basic $t }
  # multiplier 
  method _m_description {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -description }
  
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
    -object_id objectId
    -description description
  }
  #
  variable MultiplierOptionGroups {
    _m_object_id {-object_id_format -object_id_base -object_id_incr}
    _m_description {-description_format -description_base -description_incr}
  }
}

#? Children for ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange 
#-->  "::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvSn"..
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvSn
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvSn]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvSn'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvSn {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv/tlvSettings/lldpTlvSn
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kRequired
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  option -object_id \
    -cgetmethod _g_object_id -configuremethod _c_object_id -validatemethod _v_object_id \
    -default "" \
    -readonly false
  method _c_object_id {t v} {  }
  method _v_object_id {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_object_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -object_id }
  
  option -description \
    -cgetmethod _g_description -configuremethod _c_description -validatemethod _v_description \
    -default "" \
    -readonly false
  method _c_description {t v} { $self _configure_basic $t $v }
  method _v_description {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_description {t} { $self _cget_basic $t }
  # multiplier 
  method _m_description {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -description }
  
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
    -object_id objectId
    -description description
  }
  #
  variable MultiplierOptionGroups {
    _m_object_id {-object_id_format -object_id_base -object_id_incr}
    _m_description {-description_format -description_base -description_incr}
  }
}

#? master type "::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange"..
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange
  variable AncestorIncludeLevelForCreate  2
  variable AncestorIncludeLevelForAdd  1
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {../macRange - {} ../vlanRange - {}}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kRequired
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  option -mac_range_object_id \
    -configuremethod _c_../macRange/objectId \
    -cgetmethod _g_../macRange/objectId \
    -readonly false
  method _c_../macRange/objectId {t v} { $self _configure_relative ../macRange -object_id $v }
  method _g_../macRange/objectId {t} { $self _cget_relative ../macRange -object_id }
  # multiplier 
  method _m_mac_range_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -mac_range_object_id }
  
  option -mac_range_increment_by \
    -configuremethod _c_../macRange/incrementBy \
    -cgetmethod _g_../macRange/incrementBy \
    -readonly false
  method _c_../macRange/incrementBy {t v} { $self _configure_relative ../macRange -increment_by $v }
  method _g_../macRange/incrementBy {t} { $self _cget_relative ../macRange -increment_by }
  # multiplier 
  method _m_mac_range_increment_by {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -mac_range_increment_by }
  
  option -mac_range_name \
    -configuremethod _c_../macRange/name \
    -cgetmethod _g_../macRange/name \
    -readonly false
  method _c_../macRange/name {t v} { $self _configure_relative ../macRange -name $v }
  method _g_../macRange/name {t} { $self _cget_relative ../macRange -name }
  # multiplier 
  method _m_mac_range_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -mac_range_name }
  
  option -mac_range_count \
    -configuremethod _c_../macRange/count \
    -cgetmethod _g_../macRange/count \
    -readonly false
  method _c_../macRange/count {t v} { $self _configure_relative ../macRange -count $v }
  method _g_../macRange/count {t} { $self _cget_relative ../macRange -count }
  # multiplier 
  method _m_mac_range_count {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -mac_range_count }
  
  option -mac_range_mac \
    -configuremethod _c_../macRange/mac \
    -cgetmethod _g_../macRange/mac \
    -readonly false
  method _c_../macRange/mac {t v} { $self _configure_relative ../macRange -mac $v }
  method _g_../macRange/mac {t} { $self _cget_relative ../macRange -mac }
  # multiplier 
  method _m_mac_range_mac {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -mac_range_mac }
  
  option -mac_range_mtu \
    -configuremethod _c_../macRange/mtu \
    -cgetmethod _g_../macRange/mtu \
    -readonly false
  method _c_../macRange/mtu {t v} { $self _configure_relative ../macRange -mtu $v }
  method _g_../macRange/mtu {t} { $self _cget_relative ../macRange -mtu }
  # multiplier 
  method _m_mac_range_mtu {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -mac_range_mtu }
  
  option -mac_range_enabled \
    -configuremethod _c_../macRange/enabled \
    -cgetmethod _g_../macRange/enabled \
    -readonly false
  method _c_../macRange/enabled {t v} { $self _configure_relative ../macRange -enabled $v }
  method _g_../macRange/enabled {t} { $self _cget_relative ../macRange -enabled }
  option -vlan_range_inner_first_id \
    -configuremethod _c_../vlanRange/innerFirstId \
    -cgetmethod _g_../vlanRange/innerFirstId \
    -readonly false
  method _c_../vlanRange/innerFirstId {t v} { $self _configure_relative ../vlanRange -inner_first_id $v }
  method _g_../vlanRange/innerFirstId {t} { $self _cget_relative ../vlanRange -inner_first_id }
  # multiplier 
  method _m_vlan_range_inner_first_id {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_inner_first_id }
  
  option -vlan_range_inner_increment \
    -configuremethod _c_../vlanRange/innerIncrement \
    -cgetmethod _g_../vlanRange/innerIncrement \
    -readonly false
  method _c_../vlanRange/innerIncrement {t v} { $self _configure_relative ../vlanRange -inner_increment $v }
  method _g_../vlanRange/innerIncrement {t} { $self _cget_relative ../vlanRange -inner_increment }
  # multiplier 
  method _m_vlan_range_inner_increment {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_inner_increment }
  
  option -vlan_range_enabled \
    -configuremethod _c_../vlanRange/enabled \
    -cgetmethod _g_../vlanRange/enabled \
    -readonly false
  method _c_../vlanRange/enabled {t v} { $self _configure_relative ../vlanRange -enabled $v }
  method _g_../vlanRange/enabled {t} { $self _cget_relative ../vlanRange -enabled }
  option -vlan_range_unique_count \
    -configuremethod _c_../vlanRange/uniqueCount \
    -cgetmethod _g_../vlanRange/uniqueCount \
    -readonly false
  method _c_../vlanRange/uniqueCount {t v} { $self _configure_relative ../vlanRange -unique_count $v }
  method _g_../vlanRange/uniqueCount {t} { $self _cget_relative ../vlanRange -unique_count }
  # multiplier 
  method _m_vlan_range_unique_count {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_unique_count }
  
  option -vlan_range_name \
    -configuremethod _c_../vlanRange/name \
    -cgetmethod _g_../vlanRange/name \
    -readonly false
  method _c_../vlanRange/name {t v} { $self _configure_relative ../vlanRange -name $v }
  method _g_../vlanRange/name {t} { $self _cget_relative ../vlanRange -name }
  # multiplier 
  method _m_vlan_range_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -vlan_range_name }
  
  option -vlan_range_increment_step \
    -configuremethod _c_../vlanRange/incrementStep \
    -cgetmethod _g_../vlanRange/incrementStep \
    -readonly false
  method _c_../vlanRange/incrementStep {t v} { $self _configure_relative ../vlanRange -increment_step $v }
  method _g_../vlanRange/incrementStep {t} { $self _cget_relative ../vlanRange -increment_step }
  # multiplier 
  method _m_vlan_range_increment_step {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_increment_step }
  
  option -vlan_range_tpid \
    -configuremethod _c_../vlanRange/tpid \
    -cgetmethod _g_../vlanRange/tpid \
    -readonly false
  method _c_../vlanRange/tpid {t v} { $self _configure_relative ../vlanRange -tpid $v }
  method _g_../vlanRange/tpid {t} { $self _cget_relative ../vlanRange -tpid }
  # multiplier 
  method _m_vlan_range_tpid {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -vlan_range_tpid }
  
  option -vlan_range_priority \
    -configuremethod _c_../vlanRange/priority \
    -cgetmethod _g_../vlanRange/priority \
    -readonly false
  method _c_../vlanRange/priority {t v} { $self _configure_relative ../vlanRange -priority $v }
  method _g_../vlanRange/priority {t} { $self _cget_relative ../vlanRange -priority }
  # multiplier 
  method _m_vlan_range_priority {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_priority }
  
  option -vlan_range_inner_enable \
    -configuremethod _c_../vlanRange/innerEnable \
    -cgetmethod _g_../vlanRange/innerEnable \
    -readonly false
  method _c_../vlanRange/innerEnable {t v} { $self _configure_relative ../vlanRange -inner_enable $v }
  method _g_../vlanRange/innerEnable {t} { $self _cget_relative ../vlanRange -inner_enable }
  option -vlan_range_object_id \
    -configuremethod _c_../vlanRange/objectId \
    -cgetmethod _g_../vlanRange/objectId \
    -readonly false
  method _c_../vlanRange/objectId {t v} { $self _configure_relative ../vlanRange -object_id $v }
  method _g_../vlanRange/objectId {t} { $self _cget_relative ../vlanRange -object_id }
  # multiplier 
  method _m_vlan_range_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -vlan_range_object_id }
  
  option -vlan_range_inner_unique_count \
    -configuremethod _c_../vlanRange/innerUniqueCount \
    -cgetmethod _g_../vlanRange/innerUniqueCount \
    -readonly false
  method _c_../vlanRange/innerUniqueCount {t v} { $self _configure_relative ../vlanRange -inner_unique_count $v }
  method _g_../vlanRange/innerUniqueCount {t} { $self _cget_relative ../vlanRange -inner_unique_count }
  # multiplier 
  method _m_vlan_range_inner_unique_count {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_inner_unique_count }
  
  option -vlan_range_inner_tpid \
    -configuremethod _c_../vlanRange/innerTpid \
    -cgetmethod _g_../vlanRange/innerTpid \
    -readonly false
  method _c_../vlanRange/innerTpid {t v} { $self _configure_relative ../vlanRange -inner_tpid $v }
  method _g_../vlanRange/innerTpid {t} { $self _cget_relative ../vlanRange -inner_tpid }
  # multiplier 
  method _m_vlan_range_inner_tpid {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -vlan_range_inner_tpid }
  
  option -vlan_range_first_id \
    -configuremethod _c_../vlanRange/firstId \
    -cgetmethod _g_../vlanRange/firstId \
    -readonly false
  method _c_../vlanRange/firstId {t v} { $self _configure_relative ../vlanRange -first_id $v }
  method _g_../vlanRange/firstId {t} { $self _cget_relative ../vlanRange -first_id }
  # multiplier 
  method _m_vlan_range_first_id {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_first_id }
  
  option -vlan_range_increment \
    -configuremethod _c_../vlanRange/increment \
    -cgetmethod _g_../vlanRange/increment \
    -readonly false
  method _c_../vlanRange/increment {t v} { $self _configure_relative ../vlanRange -increment $v }
  method _g_../vlanRange/increment {t} { $self _cget_relative ../vlanRange -increment }
  # multiplier 
  method _m_vlan_range_increment {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_increment }
  
  option -vlan_range_inner_increment_step \
    -configuremethod _c_../vlanRange/innerIncrementStep \
    -cgetmethod _g_../vlanRange/innerIncrementStep \
    -readonly false
  method _c_../vlanRange/innerIncrementStep {t v} { $self _configure_relative ../vlanRange -inner_increment_step $v }
  method _g_../vlanRange/innerIncrementStep {t} { $self _cget_relative ../vlanRange -inner_increment_step }
  # multiplier 
  method _m_vlan_range_inner_increment_step {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_inner_increment_step }
  
  option -vlan_range_id_incr_mode \
    -configuremethod _c_../vlanRange/idIncrMode \
    -cgetmethod _g_../vlanRange/idIncrMode \
    -readonly false
  method _c_../vlanRange/idIncrMode {t v} { $self _configure_relative ../vlanRange -id_incr_mode $v }
  method _g_../vlanRange/idIncrMode {t} { $self _cget_relative ../vlanRange -id_incr_mode }
  # multiplier 
  method _m_vlan_range_id_incr_mode {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_id_incr_mode }
  
  option -vlan_range_inner_priority \
    -configuremethod _c_../vlanRange/innerPriority \
    -cgetmethod _g_../vlanRange/innerPriority \
    -readonly false
  method _c_../vlanRange/innerPriority {t v} { $self _configure_relative ../vlanRange -inner_priority $v }
  method _g_../vlanRange/innerPriority {t} { $self _cget_relative ../vlanRange -inner_priority }
  # multiplier 
  method _m_vlan_range_inner_priority {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_inner_priority }
  
  option -vlan_range_vlan_id_info \
    -configuremethod _c_../vlanRange/vlanIdInfo \
    -cgetmethod _g_../vlanRange/vlanIdInfo \
    -readonly false
  method _c_../vlanRange/vlanIdInfo {t v} { $self _configure_relative ../vlanRange -vlan_id_info $v }
  method _g_../vlanRange/vlanIdInfo {t} { $self _cget_relative ../vlanRange -vlan_id_info }
  option -tx_interval \
    -cgetmethod _g_tx_interval -configuremethod _c_tx_interval -validatemethod _v_tx_interval \
    -default "" \
    -readonly false
  method _c_tx_interval {t v} { $self _configure_basic $t $v }
  method _v_tx_interval {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_tx_interval {t} { $self _cget_basic $t }
  # multiplier 
  method _m_tx_interval {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -tx_interval }
  
  option -fast_init_enable \
    -cgetmethod _g_fast_init_enable -configuremethod _c_fast_init_enable -validatemethod _v_fast_init_enable \
    -default "" \
    -readonly false
  method _c_fast_init_enable {t v} { $self _configure_basic $t $v }
  method _v_fast_init_enable {t v} { ::ixia::hag::ixn::validate::kBool $t $v }
  method _g_fast_init_enable {t} { $self _cget_kBool $t }
  option -enabled \
    -cgetmethod _g_enabled -configuremethod _c_enabled -validatemethod _v_enabled \
    -default "" \
    -readonly false
  method _c_enabled {t v} { $self _configure_basic $t $v }
  method _v_enabled {t v} { ::ixia::hag::ixn::validate::kBool $t $v }
  method _g_enabled {t} { $self _cget_kBool $t }
  option -chassis_id \
    -cgetmethod _g_chassis_id -configuremethod _c_chassis_id -validatemethod _v_chassis_id \
    -default "" \
    -readonly false
  method _c_chassis_id {t v} { $self _configure_basic $t $v }
  method _v_chassis_id {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_chassis_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_chassis_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -chassis_id }
  
  option -port_id_interface_name \
    -cgetmethod _g_port_id_interface_name -configuremethod _c_port_id_interface_name -validatemethod _v_port_id_interface_name \
    -default "" \
    -readonly false
  method _c_port_id_interface_name {t v} { $self _configure_basic $t $v }
  method _v_port_id_interface_name {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_port_id_interface_name {t} { $self _cget_basic $t }
  # multiplier 
  method _m_port_id_interface_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -port_id_interface_name }
  
  option -oui \
    -cgetmethod _g_oui -configuremethod _c_oui -validatemethod _v_oui \
    -default "" \
    -readonly false
  method _c_oui {t v} { $self _configure_basic $t $v }
  method _v_oui {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_oui {t} { $self _cget_basic $t }
  # multiplier 
  method _m_oui {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -oui }
  
  option -dest_mac_address \
    -cgetmethod _g_dest_mac_address -configuremethod _c_dest_mac_address -validatemethod _v_dest_mac_address \
    -default "" \
    -readonly false
  method _c_dest_mac_address {t v} { $self _configure_basic $t $v }
  method _v_dest_mac_address {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_dest_mac_address {t} { $self _cget_basic $t }
  # multiplier 
  method _m_dest_mac_address {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dest_mac_address }
  
  option -dcbx_enable \
    -cgetmethod _g_dcbx_enable -configuremethod _c_dcbx_enable -validatemethod _v_dcbx_enable \
    -default "" \
    -readonly false
  method _c_dcbx_enable {t v} { $self _configure_basic $t $v }
  method _v_dcbx_enable {t v} { ::ixia::hag::ixn::validate::kBool $t $v }
  method _g_dcbx_enable {t} { $self _cget_kBool $t }
  option -name \
    -cgetmethod _g_name -configuremethod _c_name -validatemethod _v_name \
    -default "" \
    -readonly false
  method _c_name {t v} { $self _configure_basic $t $v }
  method _v_name {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_name {t} { $self _cget_basic $t }
  # multiplier 
  method _m_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -name }
  
  option -port_id_mac_address \
    -cgetmethod _g_port_id_mac_address -configuremethod _c_port_id_mac_address -validatemethod _v_port_id_mac_address \
    -default "" \
    -readonly false
  method _c_port_id_mac_address {t v} { $self _configure_basic $t $v }
  method _v_port_id_mac_address {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_port_id_mac_address {t} { $self _cget_basic $t }
  # multiplier 
  method _m_port_id_mac_address {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -port_id_mac_address }
  
  option -control_tlv_max_version \
    -cgetmethod _g_control_tlv_max_version -configuremethod _c_control_tlv_max_version -validatemethod _v_control_tlv_max_version \
    -default "" \
    -readonly false
  method _c_control_tlv_max_version {t v} { $self _configure_basic $t $v }
  method _v_control_tlv_max_version {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_control_tlv_max_version {t} { $self _cget_basic $t }
  # multiplier 
  method _m_control_tlv_max_version {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -control_tlv_max_version }
  
  option -tx_delay \
    -cgetmethod _g_tx_delay -configuremethod _c_tx_delay -validatemethod _v_tx_delay \
    -default "" \
    -readonly false
  method _c_tx_delay {t v} { $self _configure_basic $t $v }
  method _v_tx_delay {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_tx_delay {t} { $self _cget_basic $t }
  # multiplier 
  method _m_tx_delay {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -tx_delay }
  
  option -object_id \
    -cgetmethod _g_object_id -configuremethod _c_object_id -validatemethod _v_object_id \
    -default "" \
    -readonly false
  method _c_object_id {t v} {  }
  method _v_object_id {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_object_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -object_id }
  
  option -dcbx_subtype \
    -cgetmethod _g_dcbx_subtype -configuremethod _c_dcbx_subtype -validatemethod _v_dcbx_subtype \
    -default "" \
    -readonly false
  method _c_dcbx_subtype {t v} { $self _configure_basic $t $v }
  method _v_dcbx_subtype {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_dcbx_subtype {t} { $self _cget_basic $t }
  # multiplier 
  method _m_dcbx_subtype {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -dcbx_subtype }
  
  option -port_id_sub_type \
    -cgetmethod _g_port_id_sub_type -configuremethod _c_port_id_sub_type -validatemethod _v_port_id_sub_type \
    -default "" \
    -readonly false
  method _c_port_id_sub_type {t v} { $self _configure_basic $t $v }
  method _v_port_id_sub_type {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_port_id_sub_type {t} { $self _cget_basic $t }
  # multiplier 
  method _m_port_id_sub_type {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -port_id_sub_type }
  
  option -hold_time \
    -cgetmethod _g_hold_time -configuremethod _c_hold_time -validatemethod _v_hold_time \
    -default "" \
    -readonly false
  method _c_hold_time {t v} { $self _configure_basic $t $v }
  method _v_hold_time {t v} { ::ixia::hag::ixn::validate::kInteger64 $t $v }
  method _g_hold_time {t} { $self _cget_basic $t }
  # multiplier 
  method _m_hold_time {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -hold_time }
  
  option -lldp_tlv \
    -cgetmethod _g_lldp_tlv -configuremethod _c_lldp_tlv -validatemethod _v_lldp_tlv \
    -default "" \
    -readonly false
  method _c_lldp_tlv {t v} { $self _configure_kList_as_list /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv $t $v }
  method _v_lldp_tlv {t v} { $self _validate_kList_as_list /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv $t $v }
  method _g_lldp_tlv {t} { $self _cget_basic $t }
  option -lldp_tlvmulti \
    -cgetmethod _g_lldp_tlvmulti -configuremethod _c_lldp_tlvmulti -validatemethod _v_lldp_tlvmulti \
    -default "" \
    -readonly false
  method _c_lldp_tlvmulti {t v} { $self _configure_kList_as_multiplier /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv $t $v }
  method _v_lldp_tlvmulti {t v} { $self _validate_kList_as_multiplier /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/lldpTlv $t $v }
  method _g_lldp_tlvmulti {t} { $self _cget_basic $t }
  option -dcbx_tlv_qaz \
    -cgetmethod _g_dcbx_tlv_qaz -configuremethod _c_dcbx_tlv_qaz -validatemethod _v_dcbx_tlv_qaz \
    -default "" \
    -readonly false
  method _c_dcbx_tlv_qaz {t v} { $self _configure_kList_as_list /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlvQaz $t $v }
  method _v_dcbx_tlv_qaz {t v} { $self _validate_kList_as_list /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlvQaz $t $v }
  method _g_dcbx_tlv_qaz {t} { $self _cget_basic $t }
  option -dcbx_tlv_qazmulti \
    -cgetmethod _g_dcbx_tlv_qazmulti -configuremethod _c_dcbx_tlv_qazmulti -validatemethod _v_dcbx_tlv_qazmulti \
    -default "" \
    -readonly false
  method _c_dcbx_tlv_qazmulti {t v} { $self _configure_kList_as_multiplier /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlvQaz $t $v }
  method _v_dcbx_tlv_qazmulti {t v} { $self _validate_kList_as_multiplier /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlvQaz $t $v }
  method _g_dcbx_tlv_qazmulti {t} { $self _cget_basic $t }
  option -dcbx_tlv \
    -cgetmethod _g_dcbx_tlv -configuremethod _c_dcbx_tlv -validatemethod _v_dcbx_tlv \
    -default "" \
    -readonly false
  method _c_dcbx_tlv {t v} { $self _configure_kList_as_list /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlv $t $v }
  method _v_dcbx_tlv {t v} { $self _validate_kList_as_list /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlv $t $v }
  method _g_dcbx_tlv {t} { $self _cget_basic $t }
  option -dcbx_tlvmulti \
    -cgetmethod _g_dcbx_tlvmulti -configuremethod _c_dcbx_tlvmulti -validatemethod _v_dcbx_tlvmulti \
    -default "" \
    -readonly false
  method _c_dcbx_tlvmulti {t v} { $self _configure_kList_as_multiplier /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlv $t $v }
  method _v_dcbx_tlvmulti {t v} { $self _validate_kList_as_multiplier /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange/dcbxTlv $t $v }
  method _g_dcbx_tlvmulti {t} { $self _cget_basic $t }
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
    -mac_range_object_id ../macRange/objectId
    -mac_range_increment_by ../macRange/incrementBy
    -mac_range_name ../macRange/name
    -mac_range_count ../macRange/count
    -mac_range_mac ../macRange/mac
    -mac_range_mtu ../macRange/mtu
    -mac_range_enabled ../macRange/enabled
    -vlan_range_inner_first_id ../vlanRange/innerFirstId
    -vlan_range_inner_increment ../vlanRange/innerIncrement
    -vlan_range_enabled ../vlanRange/enabled
    -vlan_range_unique_count ../vlanRange/uniqueCount
    -vlan_range_name ../vlanRange/name
    -vlan_range_increment_step ../vlanRange/incrementStep
    -vlan_range_tpid ../vlanRange/tpid
    -vlan_range_priority ../vlanRange/priority
    -vlan_range_inner_enable ../vlanRange/innerEnable
    -vlan_range_object_id ../vlanRange/objectId
    -vlan_range_inner_unique_count ../vlanRange/innerUniqueCount
    -vlan_range_inner_tpid ../vlanRange/innerTpid
    -vlan_range_first_id ../vlanRange/firstId
    -vlan_range_increment ../vlanRange/increment
    -vlan_range_inner_increment_step ../vlanRange/innerIncrementStep
    -vlan_range_id_incr_mode ../vlanRange/idIncrMode
    -vlan_range_inner_priority ../vlanRange/innerPriority
    -vlan_range_vlan_id_info ../vlanRange/vlanIdInfo
    -tx_interval txInterval
    -fast_init_enable fastInitEnable
    -enabled enabled
    -chassis_id chassisId
    -port_id_interface_name portIdInterfaceName
    -oui oui
    -dest_mac_address destMacAddress
    -dcbx_enable dcbxEnable
    -name name
    -port_id_mac_address portIdMacAddress
    -control_tlv_max_version controlTlvMaxVersion
    -tx_delay txDelay
    -object_id objectId
    -dcbx_subtype dcbxSubtype
    -port_id_sub_type portIdSubType
    -hold_time holdTime
  }
  #
  variable MultiplierOptionGroups {
    _m_mac_range_object_id {-mac_range_object_id_format -mac_range_object_id_base -mac_range_object_id_incr}
    _m_mac_range_increment_by {-mac_range_increment_by_format -mac_range_increment_by_base -mac_range_increment_by_incr}
    _m_mac_range_name {-mac_range_name_format -mac_range_name_base -mac_range_name_incr}
    _m_mac_range_count {-mac_range_count_base -mac_range_count_incr}
    _m_mac_range_mac {-mac_range_mac_format -mac_range_mac_base -mac_range_mac_incr}
    _m_mac_range_mtu {-mac_range_mtu_base -mac_range_mtu_incr}
    _m_vlan_range_inner_first_id {-vlan_range_inner_first_id_base -vlan_range_inner_first_id_incr}
    _m_vlan_range_inner_increment {-vlan_range_inner_increment_base -vlan_range_inner_increment_incr}
    _m_vlan_range_unique_count {-vlan_range_unique_count_base -vlan_range_unique_count_incr}
    _m_vlan_range_name {-vlan_range_name_format -vlan_range_name_base -vlan_range_name_incr}
    _m_vlan_range_increment_step {-vlan_range_increment_step_base -vlan_range_increment_step_incr}
    _m_vlan_range_tpid {-vlan_range_tpid_format -vlan_range_tpid_base -vlan_range_tpid_incr}
    _m_vlan_range_priority {-vlan_range_priority_base -vlan_range_priority_incr}
    _m_vlan_range_object_id {-vlan_range_object_id_format -vlan_range_object_id_base -vlan_range_object_id_incr}
    _m_vlan_range_inner_unique_count {-vlan_range_inner_unique_count_base -vlan_range_inner_unique_count_incr}
    _m_vlan_range_inner_tpid {-vlan_range_inner_tpid_format -vlan_range_inner_tpid_base -vlan_range_inner_tpid_incr}
    _m_vlan_range_first_id {-vlan_range_first_id_base -vlan_range_first_id_incr}
    _m_vlan_range_increment {-vlan_range_increment_base -vlan_range_increment_incr}
    _m_vlan_range_inner_increment_step {-vlan_range_inner_increment_step_base -vlan_range_inner_increment_step_incr}
    _m_vlan_range_id_incr_mode {-vlan_range_id_incr_mode_base -vlan_range_id_incr_mode_incr}
    _m_vlan_range_inner_priority {-vlan_range_inner_priority_base -vlan_range_inner_priority_incr}
    _m_tx_interval {-tx_interval_base -tx_interval_incr}
    _m_chassis_id {-chassis_id_format -chassis_id_base -chassis_id_incr}
    _m_port_id_interface_name {-port_id_interface_name_format -port_id_interface_name_base -port_id_interface_name_incr}
    _m_oui {-oui_format -oui_base -oui_incr}
    _m_dest_mac_address {-dest_mac_address_format -dest_mac_address_base -dest_mac_address_incr}
    _m_name {-name_format -name_base -name_incr}
    _m_port_id_mac_address {-port_id_mac_address_format -port_id_mac_address_base -port_id_mac_address_incr}
    _m_control_tlv_max_version {-control_tlv_max_version_base -control_tlv_max_version_incr}
    _m_tx_delay {-tx_delay_base -tx_delay_incr}
    _m_object_id {-object_id_format -object_id_base -object_id_incr}
    _m_dcbx_subtype {-dcbx_subtype_base -dcbx_subtype_incr}
    _m_port_id_sub_type {-port_id_sub_type_base -port_id_sub_type_incr}
    _m_hold_time {-hold_time_base -hold_time_incr}
  }
}

#@ ancestors for ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange
#@@ ancestor "::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint"..
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kList
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  option -_global_options \
    -cgetmethod _g__global_options -configuremethod _c__global_options -validatemethod _v__global_options \
    -default "" \
    -readonly false
  method _c__global_options {t v} { $self _configure_basic $t $v }
  method _v__global_options {t v} { ::ixia::hag::ixn::validate::kObjref $t $v }
  method _g__global_options {t} { $self _cget_basic $t }
  option -_port_options \
    -cgetmethod _g__port_options -configuremethod _c__port_options -validatemethod _v__port_options \
    -default "" \
    -readonly false
  method _c__port_options {t v} { $self _configure_basic $t $v }
  method _v__port_options {t v} { ::ixia::hag::ixn::validate::kObjref $t $v }
  method _g__port_options {t} { $self _cget_basic $t }
  option -object_id \
    -cgetmethod _g_object_id -configuremethod _c_object_id -validatemethod _v_object_id \
    -default "" \
    -readonly false
  method _c_object_id {t v} {  }
  method _v_object_id {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_object_id {t} { $self _cget_basic $t }
  # multiplier 
  method _m_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -object_id }
  
  option -name \
    -cgetmethod _g_name -configuremethod _c_name -validatemethod _v_name \
    -default "" \
    -readonly false
  method _c_name {t v} { $self _configure_basic $t $v }
  method _v_name {t v} { ::ixia::hag::ixn::validate::kString $t $v }
  method _g_name {t} { $self _cget_basic $t }
  # multiplier 
  method _m_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -name }
  
  # XCHILD
  # /vport/protocolStack/ethernet/dcbxEndpoint/range
  option -range_handle -default UNDEFINED
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
    -_global_options _globalOptions
    -_port_options _portOptions
    -object_id objectId
    -name name
    -range_handle range
  }
  #
  variable MultiplierOptionGroups {
    _m_object_id {-object_id_format -object_id_base -object_id_incr}
    _m_name {-name_format -name_base -name_incr}
  }
}

#@@ ancestor "::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range"..
#------------------------------------------------------------------
# Prolog for: /vport/protocolStack/ethernet/dcbxEndpoint/range
package require snit
foreach {ns} {
  ::ixia::hag::ixn ::ixia::hag::ixn::auto ::ixia::hag::ixn::types
} {
  if {![namespace exists $ns]} { namespace eval $ns {} }
}
if {[llength [info commands ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range]]} {
    #puts stderr "Note: There was already a command called 'snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range'"
}

snit::type ::ixia::hag::ixn::types::/vport/protocolStack/ethernet/dcbxEndpoint/range {
  
  # Options used to generate this code
  typevariable GenerateOptions {
    -ancestor-include-level-for-add 1
    -ancestor-include-level-for-create 2
    -anx2hlt-file auto
    -anx2hlt-hltapi-command-element-attrs {}
    -anx2hlt-hltapi-param-element-attrs {@path-dcbxRange,../vlanRange/name,value_translator cgs.xlt.hag_vlan_id_info}
    -anx2hlt-typepath-links {}
    -children-processing include-all
    -children-processing-for-types {}
    -command-name dcbxrange
    -docs-chapter-name {DCBX/LLDP APIs}
    -input-include-items-with-typepath {}
    -input-include-items-with-typepath-anx2hlt {}
    -input-ixnmetadata-file ./lib/ixnmetadata-9.10/vport-ixnmetadata.xml,./lib/ixnmetadata-9.10/globals-ixnmetadata.xml
    -input-ixnmetadata-typepath /vport
    -input-skip-items-with-typepath {*/dcbxTlv/* * * */dcbxTlvQaz/* * *}
    -input-skip-items-with-typepath-anx2hlt {*/dcbxTlv * * */dcbxTlv/* * * */dcbxTlvQaz * * */dcbxTlvQaz/* * *}
    -input-tailor-file {}
    -input-tailor-file-mandatory 1
    -ixn-tclserver-hostname localhost
    -option-prefixes-for-types {}
    -output-directory ./directions
    -output-library-file {}
    -output-multiplier-option-groups 1
    -output-package-name {}
    -output-package-version 1.0
    -output-package-write-mode w+
    -parent-binding-mode always
    -parent-binding-style none
    -parent-handle-typepath /vport
    -relative-includes {*/protocolStack/ethernet/*/range/dcbxRange {{../macRange -} {../vlanRange -}}}
    -rules-file {}
    -shared-includes {}
    -sub-commands {config control stats}
    -type-for-command dcbxRange
    -use-settings-for typical_ethernet_based_stackmanager_range_command
  }
  
  # ixn typepath associated w/ this obj
  variable TypePath /vport/protocolStack/ethernet/dcbxEndpoint/range
  variable AncestorIncludeLevelForCreate  0
  variable AncestorIncludeLevelForAdd  0
  # Ancestors that we auto-created and are managing ourselves
  # as opposed to those linked in via -parent_handle or some other
  # linkage option
  variable Ancestors {}
  # relatives of these types must be made along w/ the 
  # direct ancestry elements
  variable Relatives {}
  # carried thru from ixn SDM. kList, kManaged, kRequired, etc...
  variable Multiplicity kList
  # if this an element with a kManaged Mutiplicity, this contains
  # the managed index used by the enclosing container for ::my_codegen
  # if this thing is not kManaged, it is the empty string
  option -element_index -default ""
  # shell obj that holds utils like _create_instance, etc..
  typevariable Shell ::ixia::hag::ixn::types::shell
  # see _create
  typevariable ParentBindingStyle none
  typevariable ParentBindingMode always
  
  # A place for data managed by custom overrides
  # in tailor files
  variable UserInstanceData -array {}
  
  variable _REQUIRED_OPT "\x1"
  variable OwnIxnHandle ""
  method _own_ixn_handle {} {return $OwnIxnHandle}
  # underlying 'low level' ixn tcl handle for self
  variable IxnHandle ""
  method _ixn_handle {} {return $IxnHandle}
  method _set_ixn_handle {i_ixn_handle {i_own_ixn_handle 1}} {
      if {[string length $IxnHandle]} {
         return -code error  "Can't set to \"$i_ixn_handle\". IxnHandle is already set to $IxnHandle"
      }
      set IxnHandle $i_ixn_handle
      set OwnIxnHandle $i_own_ixn_handle
  }
  variable Parent ""
  #
  # Children: 
  # A paired list of form:
  #
  # {child_obj_0 tight ... child_obj_N loose}
  #
  # tight/loose indicated a tight binding , meaning that the child
  # should be destroyed are part of $self's destruction process
  variable Children {}
  
  typemethod _get_typevar {n} {set $n}
  method _get_var {n} {set $n}
  method _set_var {n v} {
      if {![info exists $n]} {
          return -code error "No such variable \"$n\""
      }
      set $n $v
  }
  method _parent {} {return $Parent}
  method _top_ancestor {} {
      if {[string length $Parent] == 0} {
          return -code error "$self: parent is undefined"
      }
      set x_obj $Parent
      while {[string length $x_obj]} {
          set rval $x_obj
          set x_obj [$x_obj _parent]
      }
      return $rval;
  }
  method _ancestor {lvl} {
      if {$lvl<0} {
          return -code error  "$self: Level ($lvl) must be a positive #"
      } elseif {$lvl == 0} {
          return $self
      }
      incr lvl -1; set rval $Parent
      #puts stderr "$self parent -> $Parent"
      for {} {$lvl>0} {incr lvl -1} {
          set rval [$rval _parent]
      }
      return $rval
  }
  method _descendant {i_typepath} {
      set rval $self
      foreach {elem} [$self _typepath_split $i_typepath] {
          set found 0
          foreach {child child_mode} [$rval _get_var Children] {
              set t [$child _typepath_tail [$child _typepath]]
              if {[string equal $t  $elem]} {
                  set rval $child
                  set found 1
                  break;
              }
          }
          if {$found == 0} {
              return -code error  "$self: cannot find descendant $i_typepath"
          }
      }
      return $rval
  }
  
  method _relative {i_relative_tp {include_ancestors 0}} {
      set rval ""
      foreach {relative_tp share_tp inst} $Relatives {
          if {[string equal $relative_tp  $i_relative_tp]} {
              # sanity check..
              if {[string length $rval]} {
                  return -code error  "more than one relative \"$i_relative_tp\""
              }
              set rval $inst
          }
      }
      if {$include_ancestors} {
        set fq_tp [$self _typepath_normalize  [$self _typepath_join [$self _typepath] $i_relative_tp]]
        set alist {}
        foreach {a} $Ancestors {
          set ap [$a _typepath]
          lappend alist $ap
          if {[string equal $ap $fq_tp]} {
              # sanity check..
              if {[string length $rval]} {
                return -code error  "more than one relative/ancestor \"$i_relative_tp\""
              }
              set rval $a
          }
        }
      }
      if {[string length $rval] == 0} {
          if {$include_ancestors} {
              set what "relatives/ancestors"
              set astuff "with ancestors $alist"
          } else {
              set what "relatives"
              set astuff ""
          }
          return -code error  "$self: Cannot find relative $i_relative_tp: existing $what are:\n------\n$Relatives\n$astuff\n-----\n"
      }
      return $rval
  }
  
  
  method abort        {} { $Shell abort $self }
  method abort_async  {} { $Shell abort_async $self}
  method start        {} { $Shell start $self }
  method stop         {} { $Shell stop  $self }
  
  #--------------------------------------------------------------------
  # ixn handle creation support methods
  method _trace {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "$self: [join $args]"}
  }
  method _tr {args} {
      if [set ${Shell}::_TRACE(HAG)] {puts stderr "    [join $args]"}
  }
  method _typepath_split {p} { file split $p }
  method _typepath_parent {p} { file dirname $p }
  method _typepath_join {args} { eval [concat {file join} $args] }
  method _typepath_tail {p} { file tail $p}
  method _typepath {} { return $TypePath }
  method _typepath_normalize {p} { regsub {^[^/]+} [file normalize $p] {} }
  method _typepath_relativity {p} {
      set l 0; foreach {x} [$self _typepath_split $p] {
          if {$x !=  ".."} {break} else {incr l}
      }
      return $l
  }
  
  method _delete_ixn_subelement {i_ixn_handle} {
      $Shell _delete_ixn_subelement $self $i_ixn_handle
  }
  method _add_ixn_subelement {element_inst element_name} {
      $Shell _add_ixn_subelement $self $element_inst $element_name
  }
  
  method _bind_to_parent {args} {
      array set opts {
          -parent "" -tight-binding 0 -ixn-handle ""
          -binding-mode ""
      }; array set opts $args
      if {[string length $opts(-binding-mode)] == 0} {
          set opts(-binding-mode) $ParentBindingMode
      }
      set child $self
      if {[lsearch {internal_default tight loose none}  $opts(-tight-binding)] >= 0} {
          set child_mode $opts(-tight-binding)
      } else {
          if {[string length $opts(-tight-binding)] == 0} {
              set child_mode "none"
          } elseif {$opts(-tight-binding)} {
              set child_mode "tight"
          } else {
              set child_mode "loose"
          }
      }
      if {[string equal $child_mode "internal_default"]} {
          set child_mode $ParentBindingStyle
      }
      unset opts(-tight-binding)
      if {$child_mode == "none"} {
          return
      }                
      
      $self _tr "$opts(-parent) <- Binding to"
      if {[string length $Parent]} {
          if {$opts(-binding-mode) != "ifneeded"} {
              set msg  "$opts(-parent) <- Binding to already has parent $Parent"
              $self _tr $msg
              return -code error $msg
          } else {
              return
          }
      }
      set Parent $opts(-parent)
      if {[llength [info commands $Parent]] != 1} {
          return -code error  "$self:Parent \"$Parent\" is not a legal object"
      }
  
      if {[string length $opts(-ixn-handle)] == 0} {
          if {[string length [$self _ixn_handle]]} {
            set msg "Already have _ixn_handle \"[$self _ixn_handle]\""
            return -code error $msg
          }
          $self _set_ixn_handle [$Parent  _add_ixn_subelement  $self  [$self _typepath_tail $TypePath]]
      } else {
          $self _set_ixn_handle $opts(-ixn-handle)
      }
  
      $self configurelist [$self _alterations_to_option_defaults]
      $Parent _set_var Children [concat  [$Parent _get_var Children] [list $child $child_mode]  ]
  }
  
  
  method _configure_args_multiplier {m n args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _configure_args_multiplier $self $m $n $args
  }
  
  typemethod _pluck_o {main_opt opt default alistN} {
      upvar 1 $alistN alist
      set li [lsearch -exact $alist $opt]
      set ll [llength $alist]
      if {($li < 0)} {
          if {$default == $_REQUIRED_OPT} {
              return -code error  "Option \"$main_opt\" requires the option \"$opt\" to also be specified."
          }
      }
      set rval [lindex $alist [expr $li+1]]
      set alist [lreplace $alist $li [expr $li+1]]
      return $rval
  }
  #
  # a return of empty list means there is no option group
  # for the supplied option $opt 
  #
  # the arglistN reference will be
  # modfied (found modifier options will removed) 
  # if an option group is found for $opt
  #
  method _multiplier_opt_group {i_opt arglistN} {
      set rval {}
      upvar 1 $arglistN arglist
      foreach {mcmd mog} $MultiplierOptionGroups {
          if {[lsearch -exact $mog $i_opt] != -1} {
              lappend rval $mcmd
              set expanded_mog {} 
              # remove the mog options from args
              foreach {mo} $mog {
                  set mv [$type _pluck_o  $i_opt $mo $_REQUIRED_OPT arglist]
                  lappend expanded_mog $mo $mv
              }
              lappend rval $expanded_mog
              break
          }
      }
      return $rval
  }
  
  # Do any special initialization that should occur 
  # after the instance has been created via xxx_config create|add
  # and it's initial properties have been configured
  #
  # Intended to be overrideable
  method _post_construct_callback {args} {}
  
  #
  # callback to do any conversion needed to make what we are passed
  # an XYZ object w/ a proper ixn handle associated w/ it
  # By default, the handle passed is used as is
  #
  # Intended to be overrideable
  method _cast_handle_to_parent_obj {initial_parent_handle args} {
      return $initial_parent_handle
  }
  method _create_clan {initial_parent_handle ancestor_inc_level} {
    $Shell _create_clan $self $initial_parent_handle $ancestor_inc_level
  }
  method _create_relatives {} {$Shell _create_relatives $self}
  method _create_ancestry {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      $Shell _create_ancestry $self $args
  }
  method _destroy_clan {} {$Shell _destroy_clan $self}
  method _destroy_children {} {$Shell _destroy_children $self}
  method _destroy_relatives {} {$Shell _destroy_relatives $self}
  method _destroy_ancestry {} {$Shell _destroy_ancestry $self}
  
  method _cget_kBool {t} {
      # ixn is arbitrary on this. return normalized True/False 
      $Shell _check_ixnhandle $self
      if {[$Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)]} {
          return True
      }
      return False
  }
  method _cget_basic {t} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet getAttribute  [$self _ixn_handle] -$Opt2IxnName($t)
  }
  method _configure_basic {t v} {
      $Shell _check_ixnhandle $self
      $Shell _ixn_eval ixNet setAttribute  [$self _ixn_handle] -$Opt2IxnName($t) $v
  }
  method _validate_basic {t v} {
      if {false} { 
          return -code error "expected a ??? value, got $v"
      }
  }
  
  method _configure_kManaged_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set err ""
          set element_index ""
          catch {set element_index  [$Shell arg_pluck -element_index subobj_tv_list $err]} err
          set inst [$Shell _create_instance $ixn_typepath  -element_index $element_index]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kManaged_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_list {ixn_typepath t v} {
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      foreach {subobj_tv_list} $v {
          set inst [$Shell _create_instance $ixn_typepath]
          $inst _bind_to_parent -parent $self -tight-binding 1
          $inst _create_relatives
          $Shell _configure_instance $inst $subobj_tv_list
      }
  }
  method _validate_kList_as_list {ixn_typepath t v} {
  }
  
  method _configure_kList_as_multiplier {ixn_typepath t v} {
      # "Tighten on up !" -- James Brown
      set subobj_args [concat {-tight-binding 1} $v]
      set err "missing -count option."
      set parent_handle $self
      set count [$Shell arg_pluck -count subobj_args $err]
      # Clear existing list (if any)
      $self _destroy_children
      # (Re)build list w/ supplied items
      $Shell _multi_create $count $parent_handle  $ixn_typepath $subobj_args
  }
  method _validate_kList_as_multiplier {ixn_typepath t v} {
  }
  
  method _cget_relative {relative_typepath t} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _cget_instance $inst $t
  }
  method _configure_relative {relative_typepath t v} {
      set inst [$self _relative $relative_typepath 1];#include ancestors
      $Shell _configure_instance $inst [list $t $v]
  }
  
  #------------------------------------------------------
  # options that are mapped to ixn properties
  #
  
  option -esmc_range_object_id \
    -configuremethod _c_./esmcRange/objectId \
    -cgetmethod _g_./esmcRange/objectId \
    -readonly false
  method _c_./esmcRange/objectId {t v} { $self _configure_relative ./esmcRange -object_id $v }
  method _g_./esmcRange/objectId {t} { $self _cget_relative ./esmcRange -object_id }
  # multiplier 
  method _m_esmc_range_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -esmc_range_object_id }
  
  option -esmc_range_rate \
    -configuremethod _c_./esmcRange/rate \
    -cgetmethod _g_./esmcRange/rate \
    -readonly false
  method _c_./esmcRange/rate {t v} { $self _configure_relative ./esmcRange -rate $v }
  method _g_./esmcRange/rate {t} { $self _cget_relative ./esmcRange -rate }
  # multiplier 
  method _m_esmc_range_rate {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -esmc_range_rate }
  
  option -esmc_range_name \
    -configuremethod _c_./esmcRange/name \
    -cgetmethod _g_./esmcRange/name \
    -readonly false
  method _c_./esmcRange/name {t v} { $self _configure_relative ./esmcRange -name $v }
  method _g_./esmcRange/name {t} { $self _cget_relative ./esmcRange -name }
  # multiplier 
  method _m_esmc_range_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -esmc_range_name }
  
  option -esmc_range_ql \
    -configuremethod _c_./esmcRange/ql \
    -cgetmethod _g_./esmcRange/ql \
    -readonly false
  method _c_./esmcRange/ql {t v} { $self _configure_relative ./esmcRange -ql $v }
  method _g_./esmcRange/ql {t} { $self _cget_relative ./esmcRange -ql }
  # multiplier 
  method _m_esmc_range_ql {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -esmc_range_ql }
  
  option -esmc_range_wait_id \
    -configuremethod _c_./esmcRange/waitId \
    -cgetmethod _g_./esmcRange/waitId \
    -readonly false
  method _c_./esmcRange/waitId {t v} { $self _configure_relative ./esmcRange -wait_id $v }
  method _g_./esmcRange/waitId {t} { $self _cget_relative ./esmcRange -wait_id }
  option -esmc_range_enabled \
    -configuremethod _c_./esmcRange/enabled \
    -cgetmethod _g_./esmcRange/enabled \
    -readonly false
  method _c_./esmcRange/enabled {t v} { $self _configure_relative ./esmcRange -enabled $v }
  method _g_./esmcRange/enabled {t} { $self _cget_relative ./esmcRange -enabled }
  option -esmc_range_flag_mode \
    -configuremethod _c_./esmcRange/flagMode \
    -cgetmethod _g_./esmcRange/flagMode \
    -readonly false
  method _c_./esmcRange/flagMode {t v} { $self _configure_relative ./esmcRange -flag_mode $v }
  method _g_./esmcRange/flagMode {t} { $self _cget_relative ./esmcRange -flag_mode }
  # multiplier 
  method _m_esmc_range_flag_mode {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -esmc_range_flag_mode }
  
  option -dot1x_range_user_password \
    -configuremethod _c_./dot1xRange/userPassword \
    -cgetmethod _g_./dot1xRange/userPassword \
    -readonly false
  method _c_./dot1xRange/userPassword {t v} { $self _configure_relative ./dot1xRange -user_password $v }
  method _g_./dot1xRange/userPassword {t} { $self _cget_relative ./dot1xRange -user_password }
  # multiplier 
  method _m_dot1x_range_user_password {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dot1x_range_user_password }
  
  option -dot1x_range_nac_sequence \
    -configuremethod _c_./dot1xRange/nacSequence \
    -cgetmethod _g_./dot1xRange/nacSequence \
    -readonly false
  method _c_./dot1xRange/nacSequence {t v} { $self _configure_relative ./dot1xRange -nac_sequence $v }
  method _g_./dot1xRange/nacSequence {t} { $self _cget_relative ./dot1xRange -nac_sequence }
  option -dot1x_range_enabled \
    -configuremethod _c_./dot1xRange/enabled \
    -cgetmethod _g_./dot1xRange/enabled \
    -readonly false
  method _c_./dot1xRange/enabled {t v} { $self _configure_relative ./dot1xRange -enabled $v }
  method _g_./dot1xRange/enabled {t} { $self _cget_relative ./dot1xRange -enabled }
  option -dot1x_range_fast_stateless_resume \
    -configuremethod _c_./dot1xRange/fastStatelessResume \
    -cgetmethod _g_./dot1xRange/fastStatelessResume \
    -readonly false
  method _c_./dot1xRange/fastStatelessResume {t v} { $self _configure_relative ./dot1xRange -fast_stateless_resume $v }
  method _g_./dot1xRange/fastStatelessResume {t} { $self _cget_relative ./dot1xRange -fast_stateless_resume }
  # multiplier 
  method _m_dot1x_range_fast_stateless_resume {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dot1x_range_fast_stateless_resume }
  
  option -dot1x_range_user_name \
    -configuremethod _c_./dot1xRange/userName \
    -cgetmethod _g_./dot1xRange/userName \
    -readonly false
  method _c_./dot1xRange/userName {t v} { $self _configure_relative ./dot1xRange -user_name $v }
  method _g_./dot1xRange/userName {t} { $self _cget_relative ./dot1xRange -user_name }
  # multiplier 
  method _m_dot1x_range_user_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dot1x_range_user_name }
  
  option -dot1x_range_host_password \
    -configuremethod _c_./dot1xRange/hostPassword \
    -cgetmethod _g_./dot1xRange/hostPassword \
    -readonly false
  method _c_./dot1xRange/hostPassword {t v} { $self _configure_relative ./dot1xRange -host_password $v }
  method _g_./dot1xRange/hostPassword {t} { $self _cget_relative ./dot1xRange -host_password }
  # multiplier 
  method _m_dot1x_range_host_password {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dot1x_range_host_password }
  
  option -dot1x_range_name \
    -configuremethod _c_./dot1xRange/name \
    -cgetmethod _g_./dot1xRange/name \
    -readonly false
  method _c_./dot1xRange/name {t v} { $self _configure_relative ./dot1xRange -name $v }
  method _g_./dot1xRange/name {t} { $self _cget_relative ./dot1xRange -name }
  # multiplier 
  method _m_dot1x_range_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dot1x_range_name }
  
  option -dot1x_range_wait_id \
    -configuremethod _c_./dot1xRange/waitId \
    -cgetmethod _g_./dot1xRange/waitId \
    -readonly false
  method _c_./dot1xRange/waitId {t v} { $self _configure_relative ./dot1xRange -wait_id $v }
  method _g_./dot1xRange/waitId {t} { $self _cget_relative ./dot1xRange -wait_id }
  option -dot1x_range_protocol \
    -configuremethod _c_./dot1xRange/protocol \
    -cgetmethod _g_./dot1xRange/protocol \
    -readonly false
  method _c_./dot1xRange/protocol {t v} { $self _configure_relative ./dot1xRange -protocol $v }
  method _g_./dot1xRange/protocol {t} { $self _cget_relative ./dot1xRange -protocol }
  # multiplier 
  method _m_dot1x_range_protocol {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dot1x_range_protocol }
  
  option -dot1x_range_fast_inner_method \
    -configuremethod _c_./dot1xRange/fastInnerMethod \
    -cgetmethod _g_./dot1xRange/fastInnerMethod \
    -readonly false
  method _c_./dot1xRange/fastInnerMethod {t v} { $self _configure_relative ./dot1xRange -fast_inner_method $v }
  method _g_./dot1xRange/fastInnerMethod {t} { $self _cget_relative ./dot1xRange -fast_inner_method }
  # multiplier 
  method _m_dot1x_range_fast_inner_method {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dot1x_range_fast_inner_method }
  
  option -dot1x_range_object_id \
    -configuremethod _c_./dot1xRange/objectId \
    -cgetmethod _g_./dot1xRange/objectId \
    -readonly false
  method _c_./dot1xRange/objectId {t v} { $self _configure_relative ./dot1xRange -object_id $v }
  method _g_./dot1xRange/objectId {t} { $self _cget_relative ./dot1xRange -object_id }
  # multiplier 
  method _m_dot1x_range_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dot1x_range_object_id }
  
  option -dot1x_range_fast_provision_mode \
    -configuremethod _c_./dot1xRange/fastProvisionMode \
    -cgetmethod _g_./dot1xRange/fastProvisionMode \
    -readonly false
  method _c_./dot1xRange/fastProvisionMode {t v} { $self _configure_relative ./dot1xRange -fast_provision_mode $v }
  method _g_./dot1xRange/fastProvisionMode {t} { $self _cget_relative ./dot1xRange -fast_provision_mode }
  # multiplier 
  method _m_dot1x_range_fast_provision_mode {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dot1x_range_fast_provision_mode }
  
  option -dot1x_range_host_auth_mode \
    -configuremethod _c_./dot1xRange/hostAuthMode \
    -cgetmethod _g_./dot1xRange/hostAuthMode \
    -readonly false
  method _c_./dot1xRange/hostAuthMode {t v} { $self _configure_relative ./dot1xRange -host_auth_mode $v }
  method _g_./dot1xRange/hostAuthMode {t} { $self _cget_relative ./dot1xRange -host_auth_mode }
  # multiplier 
  method _m_dot1x_range_host_auth_mode {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dot1x_range_host_auth_mode }
  
  option -dot1x_range_host_name \
    -configuremethod _c_./dot1xRange/hostName \
    -cgetmethod _g_./dot1xRange/hostName \
    -readonly false
  method _c_./dot1xRange/hostName {t v} { $self _configure_relative ./dot1xRange -host_name $v }
  method _g_./dot1xRange/hostName {t} { $self _cget_relative ./dot1xRange -host_name }
  # multiplier 
  method _m_dot1x_range_host_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dot1x_range_host_name }
  
  option -dcbx_range_tx_interval \
    -configuremethod _c_./dcbxRange/txInterval \
    -cgetmethod _g_./dcbxRange/txInterval \
    -readonly false
  method _c_./dcbxRange/txInterval {t v} { $self _configure_relative ./dcbxRange -tx_interval $v }
  method _g_./dcbxRange/txInterval {t} { $self _cget_relative ./dcbxRange -tx_interval }
  # multiplier 
  method _m_dcbx_range_tx_interval {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -dcbx_range_tx_interval }
  
  option -dcbx_range_fast_init_enable \
    -configuremethod _c_./dcbxRange/fastInitEnable \
    -cgetmethod _g_./dcbxRange/fastInitEnable \
    -readonly false
  method _c_./dcbxRange/fastInitEnable {t v} { $self _configure_relative ./dcbxRange -fast_init_enable $v }
  method _g_./dcbxRange/fastInitEnable {t} { $self _cget_relative ./dcbxRange -fast_init_enable }
  option -dcbx_range_enabled \
    -configuremethod _c_./dcbxRange/enabled \
    -cgetmethod _g_./dcbxRange/enabled \
    -readonly false
  method _c_./dcbxRange/enabled {t v} { $self _configure_relative ./dcbxRange -enabled $v }
  method _g_./dcbxRange/enabled {t} { $self _cget_relative ./dcbxRange -enabled }
  option -dcbx_range_chassis_id \
    -configuremethod _c_./dcbxRange/chassisId \
    -cgetmethod _g_./dcbxRange/chassisId \
    -readonly false
  method _c_./dcbxRange/chassisId {t v} { $self _configure_relative ./dcbxRange -chassis_id $v }
  method _g_./dcbxRange/chassisId {t} { $self _cget_relative ./dcbxRange -chassis_id }
  # multiplier 
  method _m_dcbx_range_chassis_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dcbx_range_chassis_id }
  
  option -dcbx_range_port_id_interface_name \
    -configuremethod _c_./dcbxRange/portIdInterfaceName \
    -cgetmethod _g_./dcbxRange/portIdInterfaceName \
    -readonly false
  method _c_./dcbxRange/portIdInterfaceName {t v} { $self _configure_relative ./dcbxRange -port_id_interface_name $v }
  method _g_./dcbxRange/portIdInterfaceName {t} { $self _cget_relative ./dcbxRange -port_id_interface_name }
  # multiplier 
  method _m_dcbx_range_port_id_interface_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dcbx_range_port_id_interface_name }
  
  option -dcbx_range_oui \
    -configuremethod _c_./dcbxRange/oui \
    -cgetmethod _g_./dcbxRange/oui \
    -readonly false
  method _c_./dcbxRange/oui {t v} { $self _configure_relative ./dcbxRange -oui $v }
  method _g_./dcbxRange/oui {t} { $self _cget_relative ./dcbxRange -oui }
  # multiplier 
  method _m_dcbx_range_oui {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dcbx_range_oui }
  
  option -dcbx_range_dest_mac_address \
    -configuremethod _c_./dcbxRange/destMacAddress \
    -cgetmethod _g_./dcbxRange/destMacAddress \
    -readonly false
  method _c_./dcbxRange/destMacAddress {t v} { $self _configure_relative ./dcbxRange -dest_mac_address $v }
  method _g_./dcbxRange/destMacAddress {t} { $self _cget_relative ./dcbxRange -dest_mac_address }
  # multiplier 
  method _m_dcbx_range_dest_mac_address {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dcbx_range_dest_mac_address }
  
  option -dcbx_range_dcbx_enable \
    -configuremethod _c_./dcbxRange/dcbxEnable \
    -cgetmethod _g_./dcbxRange/dcbxEnable \
    -readonly false
  method _c_./dcbxRange/dcbxEnable {t v} { $self _configure_relative ./dcbxRange -dcbx_enable $v }
  method _g_./dcbxRange/dcbxEnable {t} { $self _cget_relative ./dcbxRange -dcbx_enable }
  option -dcbx_range_name \
    -configuremethod _c_./dcbxRange/name \
    -cgetmethod _g_./dcbxRange/name \
    -readonly false
  method _c_./dcbxRange/name {t v} { $self _configure_relative ./dcbxRange -name $v }
  method _g_./dcbxRange/name {t} { $self _cget_relative ./dcbxRange -name }
  # multiplier 
  method _m_dcbx_range_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dcbx_range_name }
  
  option -dcbx_range_port_id_mac_address \
    -configuremethod _c_./dcbxRange/portIdMacAddress \
    -cgetmethod _g_./dcbxRange/portIdMacAddress \
    -readonly false
  method _c_./dcbxRange/portIdMacAddress {t v} { $self _configure_relative ./dcbxRange -port_id_mac_address $v }
  method _g_./dcbxRange/portIdMacAddress {t} { $self _cget_relative ./dcbxRange -port_id_mac_address }
  # multiplier 
  method _m_dcbx_range_port_id_mac_address {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dcbx_range_port_id_mac_address }
  
  option -dcbx_range_control_tlv_max_version \
    -configuremethod _c_./dcbxRange/controlTlvMaxVersion \
    -cgetmethod _g_./dcbxRange/controlTlvMaxVersion \
    -readonly false
  method _c_./dcbxRange/controlTlvMaxVersion {t v} { $self _configure_relative ./dcbxRange -control_tlv_max_version $v }
  method _g_./dcbxRange/controlTlvMaxVersion {t} { $self _cget_relative ./dcbxRange -control_tlv_max_version }
  # multiplier 
  method _m_dcbx_range_control_tlv_max_version {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -dcbx_range_control_tlv_max_version }
  
  option -dcbx_range_tx_delay \
    -configuremethod _c_./dcbxRange/txDelay \
    -cgetmethod _g_./dcbxRange/txDelay \
    -readonly false
  method _c_./dcbxRange/txDelay {t v} { $self _configure_relative ./dcbxRange -tx_delay $v }
  method _g_./dcbxRange/txDelay {t} { $self _cget_relative ./dcbxRange -tx_delay }
  # multiplier 
  method _m_dcbx_range_tx_delay {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -dcbx_range_tx_delay }
  
  option -dcbx_range_object_id \
    -configuremethod _c_./dcbxRange/objectId \
    -cgetmethod _g_./dcbxRange/objectId \
    -readonly false
  method _c_./dcbxRange/objectId {t v} { $self _configure_relative ./dcbxRange -object_id $v }
  method _g_./dcbxRange/objectId {t} { $self _cget_relative ./dcbxRange -object_id }
  # multiplier 
  method _m_dcbx_range_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -dcbx_range_object_id }
  
  option -dcbx_range_dcbx_subtype \
    -configuremethod _c_./dcbxRange/dcbxSubtype \
    -cgetmethod _g_./dcbxRange/dcbxSubtype \
    -readonly false
  method _c_./dcbxRange/dcbxSubtype {t v} { $self _configure_relative ./dcbxRange -dcbx_subtype $v }
  method _g_./dcbxRange/dcbxSubtype {t} { $self _cget_relative ./dcbxRange -dcbx_subtype }
  # multiplier 
  method _m_dcbx_range_dcbx_subtype {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -dcbx_range_dcbx_subtype }
  
  option -dcbx_range_port_id_sub_type \
    -configuremethod _c_./dcbxRange/portIdSubType \
    -cgetmethod _g_./dcbxRange/portIdSubType \
    -readonly false
  method _c_./dcbxRange/portIdSubType {t v} { $self _configure_relative ./dcbxRange -port_id_sub_type $v }
  method _g_./dcbxRange/portIdSubType {t} { $self _cget_relative ./dcbxRange -port_id_sub_type }
  # multiplier 
  method _m_dcbx_range_port_id_sub_type {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -dcbx_range_port_id_sub_type }
  
  option -dcbx_range_hold_time \
    -configuremethod _c_./dcbxRange/holdTime \
    -cgetmethod _g_./dcbxRange/holdTime \
    -readonly false
  method _c_./dcbxRange/holdTime {t v} { $self _configure_relative ./dcbxRange -hold_time $v }
  method _g_./dcbxRange/holdTime {t} { $self _cget_relative ./dcbxRange -hold_time }
  # multiplier 
  method _m_dcbx_range_hold_time {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -dcbx_range_hold_time }
  
  option -dcbx_range_lldp_tlv \
    -configuremethod _c_./dcbxRange/lldpTlv \
    -cgetmethod _g_./dcbxRange/lldpTlv \
    -readonly false
  method _c_./dcbxRange/lldpTlv {t v} { $self _configure_relative ./dcbxRange -lldp_tlv $v }
  method _g_./dcbxRange/lldpTlv {t} { $self _cget_relative ./dcbxRange -lldp_tlv }
  option -dcbx_range_dcbx_tlv_qaz \
    -configuremethod _c_./dcbxRange/dcbxTlvQaz \
    -cgetmethod _g_./dcbxRange/dcbxTlvQaz \
    -readonly false
  method _c_./dcbxRange/dcbxTlvQaz {t v} { $self _configure_relative ./dcbxRange -dcbx_tlv_qaz $v }
  method _g_./dcbxRange/dcbxTlvQaz {t} { $self _cget_relative ./dcbxRange -dcbx_tlv_qaz }
  option -dcbx_range_dcbx_tlv \
    -configuremethod _c_./dcbxRange/dcbxTlv \
    -cgetmethod _g_./dcbxRange/dcbxTlv \
    -readonly false
  method _c_./dcbxRange/dcbxTlv {t v} { $self _configure_relative ./dcbxRange -dcbx_tlv $v }
  method _g_./dcbxRange/dcbxTlv {t} { $self _cget_relative ./dcbxRange -dcbx_tlv }
  option -vic_client_range_prov_info_tlvs \
    -configuremethod _c_./vicClientRange/provInfoTlvs \
    -cgetmethod _g_./vicClientRange/provInfoTlvs \
    -readonly false
  method _c_./vicClientRange/provInfoTlvs {t v} { $self _configure_relative ./vicClientRange -prov_info_tlvs $v }
  method _g_./vicClientRange/provInfoTlvs {t} { $self _cget_relative ./vicClientRange -prov_info_tlvs }
  option -vic_client_range_object_id \
    -configuremethod _c_./vicClientRange/objectId \
    -cgetmethod _g_./vicClientRange/objectId \
    -readonly false
  method _c_./vicClientRange/objectId {t v} { $self _configure_relative ./vicClientRange -object_id $v }
  method _g_./vicClientRange/objectId {t} { $self _cget_relative ./vicClientRange -object_id }
  # multiplier 
  method _m_vic_client_range_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -vic_client_range_object_id }
  
  option -vic_client_range_macs_per_vif \
    -configuremethod _c_./vicClientRange/macsPerVif \
    -cgetmethod _g_./vicClientRange/macsPerVif \
    -readonly false
  method _c_./vicClientRange/macsPerVif {t v} { $self _configure_relative ./vicClientRange -macs_per_vif $v }
  method _g_./vicClientRange/macsPerVif {t} { $self _cget_relative ./vicClientRange -macs_per_vif }
  # multiplier 
  method _m_vic_client_range_macs_per_vif {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vic_client_range_macs_per_vif }
  
  option -vic_client_range_channel_id_start \
    -configuremethod _c_./vicClientRange/channelIdStart \
    -cgetmethod _g_./vicClientRange/channelIdStart \
    -readonly false
  method _c_./vicClientRange/channelIdStart {t v} { $self _configure_relative ./vicClientRange -channel_id_start $v }
  method _g_./vicClientRange/channelIdStart {t} { $self _cget_relative ./vicClientRange -channel_id_start }
  # multiplier 
  method _m_vic_client_range_channel_id_start {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vic_client_range_channel_id_start }
  
  option -vic_client_range_prov_info_oui \
    -configuremethod _c_./vicClientRange/provInfoOui \
    -cgetmethod _g_./vicClientRange/provInfoOui \
    -readonly false
  method _c_./vicClientRange/provInfoOui {t v} { $self _configure_relative ./vicClientRange -prov_info_oui $v }
  method _g_./vicClientRange/provInfoOui {t} { $self _cget_relative ./vicClientRange -prov_info_oui }
  # multiplier 
  method _m_vic_client_range_prov_info_oui {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -vic_client_range_prov_info_oui }
  
  option -vic_client_range_name \
    -configuremethod _c_./vicClientRange/name \
    -cgetmethod _g_./vicClientRange/name \
    -readonly false
  method _c_./vicClientRange/name {t v} { $self _configure_relative ./vicClientRange -name $v }
  method _g_./vicClientRange/name {t} { $self _cget_relative ./vicClientRange -name }
  # multiplier 
  method _m_vic_client_range_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -vic_client_range_name }
  
  option -vic_client_range_vif_active \
    -configuremethod _c_./vicClientRange/vifActive \
    -cgetmethod _g_./vicClientRange/vifActive \
    -readonly false
  method _c_./vicClientRange/vifActive {t v} { $self _configure_relative ./vicClientRange -vif_active $v }
  method _g_./vicClientRange/vifActive {t} { $self _cget_relative ./vicClientRange -vif_active }
  option -vic_client_range_tlv_offset \
    -configuremethod _c_./vicClientRange/tlvOffset \
    -cgetmethod _g_./vicClientRange/tlvOffset \
    -readonly false
  method _c_./vicClientRange/tlvOffset {t v} { $self _configure_relative ./vicClientRange -tlv_offset $v }
  method _g_./vicClientRange/tlvOffset {t} { $self _cget_relative ./vicClientRange -tlv_offset }
  # multiplier 
  method _m_vic_client_range_tlv_offset {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vic_client_range_tlv_offset }
  
  option -vic_client_range_prov_info_type \
    -configuremethod _c_./vicClientRange/provInfoType \
    -cgetmethod _g_./vicClientRange/provInfoType \
    -readonly false
  method _c_./vicClientRange/provInfoType {t v} { $self _configure_relative ./vicClientRange -prov_info_type $v }
  method _g_./vicClientRange/provInfoType {t} { $self _cget_relative ./vicClientRange -prov_info_type }
  # multiplier 
  method _m_vic_client_range_prov_info_type {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vic_client_range_prov_info_type }
  
  option -vic_client_range_enabled \
    -configuremethod _c_./vicClientRange/enabled \
    -cgetmethod _g_./vicClientRange/enabled \
    -readonly false
  method _c_./vicClientRange/enabled {t v} { $self _configure_relative ./vicClientRange -enabled $v }
  method _g_./vicClientRange/enabled {t} { $self _cget_relative ./vicClientRange -enabled }
  option -vic_client_range_channel_id_increment \
    -configuremethod _c_./vicClientRange/channelIdIncrement \
    -cgetmethod _g_./vicClientRange/channelIdIncrement \
    -readonly false
  method _c_./vicClientRange/channelIdIncrement {t v} { $self _configure_relative ./vicClientRange -channel_id_increment $v }
  method _g_./vicClientRange/channelIdIncrement {t} { $self _cget_relative ./vicClientRange -channel_id_increment }
  # multiplier 
  method _m_vic_client_range_channel_id_increment {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vic_client_range_channel_id_increment }
  
  option -ptp_range_over_mac_master_mac_increment_inter_entity \
    -configuremethod _c_./ptpRangeOverMac/masterMacIncrementInterEntity \
    -cgetmethod _g_./ptpRangeOverMac/masterMacIncrementInterEntity \
    -readonly false
  method _c_./ptpRangeOverMac/masterMacIncrementInterEntity {t v} { $self _configure_relative ./ptpRangeOverMac -master_mac_increment_inter_entity $v }
  method _g_./ptpRangeOverMac/masterMacIncrementInterEntity {t} { $self _cget_relative ./ptpRangeOverMac -master_mac_increment_inter_entity }
  # multiplier 
  method _m_ptp_range_over_mac_master_mac_increment_inter_entity {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_master_mac_increment_inter_entity }
  
  option -ptp_range_over_mac_communication_mode \
    -configuremethod _c_./ptpRangeOverMac/communicationMode \
    -cgetmethod _g_./ptpRangeOverMac/communicationMode \
    -readonly false
  method _c_./ptpRangeOverMac/communicationMode {t v} { $self _configure_relative ./ptpRangeOverMac -communication_mode $v }
  method _g_./ptpRangeOverMac/communicationMode {t} { $self _cget_relative ./ptpRangeOverMac -communication_mode }
  # multiplier 
  method _m_ptp_range_over_mac_communication_mode {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_communication_mode }
  
  option -ptp_range_over_mac_send_announce_multicast \
    -configuremethod _c_./ptpRangeOverMac/sendAnnounceMulticast \
    -cgetmethod _g_./ptpRangeOverMac/sendAnnounceMulticast \
    -readonly false
  method _c_./ptpRangeOverMac/sendAnnounceMulticast {t v} { $self _configure_relative ./ptpRangeOverMac -send_announce_multicast $v }
  method _g_./ptpRangeOverMac/sendAnnounceMulticast {t} { $self _cget_relative ./ptpRangeOverMac -send_announce_multicast }
  option -ptp_range_over_mac_follow_up_delay \
    -configuremethod _c_./ptpRangeOverMac/followUpDelay \
    -cgetmethod _g_./ptpRangeOverMac/followUpDelay \
    -readonly false
  method _c_./ptpRangeOverMac/followUpDelay {t v} { $self _configure_relative ./ptpRangeOverMac -follow_up_delay $v }
  method _g_./ptpRangeOverMac/followUpDelay {t} { $self _cget_relative ./ptpRangeOverMac -follow_up_delay }
  # multiplier 
  method _m_ptp_range_over_mac_follow_up_delay {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_follow_up_delay }
  
  option -ptp_range_over_mac_domain \
    -configuremethod _c_./ptpRangeOverMac/domain \
    -cgetmethod _g_./ptpRangeOverMac/domain \
    -readonly false
  method _c_./ptpRangeOverMac/domain {t v} { $self _configure_relative ./ptpRangeOverMac -domain $v }
  method _g_./ptpRangeOverMac/domain {t} { $self _cget_relative ./ptpRangeOverMac -domain }
  # multiplier 
  method _m_ptp_range_over_mac_domain {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_domain }
  
  option -ptp_range_over_mac_announce_drop_rate \
    -configuremethod _c_./ptpRangeOverMac/announceDropRate \
    -cgetmethod _g_./ptpRangeOverMac/announceDropRate \
    -readonly false
  method _c_./ptpRangeOverMac/announceDropRate {t v} { $self _configure_relative ./ptpRangeOverMac -announce_drop_rate $v }
  method _g_./ptpRangeOverMac/announceDropRate {t} { $self _cget_relative ./ptpRangeOverMac -announce_drop_rate }
  # multiplier 
  method _m_ptp_range_over_mac_announce_drop_rate {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_announce_drop_rate }
  
  option -ptp_range_over_mac_client_ip_increment_by \
    -configuremethod _c_./ptpRangeOverMac/clientIpIncrementBy \
    -cgetmethod _g_./ptpRangeOverMac/clientIpIncrementBy \
    -readonly false
  method _c_./ptpRangeOverMac/clientIpIncrementBy {t v} { $self _configure_relative ./ptpRangeOverMac -client_ip_increment_by $v }
  method _g_./ptpRangeOverMac/clientIpIncrementBy {t} { $self _cget_relative ./ptpRangeOverMac -client_ip_increment_by }
  # multiplier 
  method _m_ptp_range_over_mac_client_ip_increment_by {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_client_ip_increment_by }
  
  option -ptp_range_over_mac_renewal_invited \
    -configuremethod _c_./ptpRangeOverMac/renewalInvited \
    -cgetmethod _g_./ptpRangeOverMac/renewalInvited \
    -readonly false
  method _c_./ptpRangeOverMac/renewalInvited {t v} { $self _configure_relative ./ptpRangeOverMac -renewal_invited $v }
  method _g_./ptpRangeOverMac/renewalInvited {t} { $self _cget_relative ./ptpRangeOverMac -renewal_invited }
  option -ptp_range_over_mac_port_number_increment \
    -configuremethod _c_./ptpRangeOverMac/portNumberIncrement \
    -cgetmethod _g_./ptpRangeOverMac/portNumberIncrement \
    -readonly false
  method _c_./ptpRangeOverMac/portNumberIncrement {t v} { $self _configure_relative ./ptpRangeOverMac -port_number_increment $v }
  method _g_./ptpRangeOverMac/portNumberIncrement {t} { $self _cget_relative ./ptpRangeOverMac -port_number_increment }
  # multiplier 
  method _m_ptp_range_over_mac_port_number_increment {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_port_number_increment }
  
  option -ptp_range_over_mac_use_clock_identity \
    -configuremethod _c_./ptpRangeOverMac/useClockIdentity \
    -cgetmethod _g_./ptpRangeOverMac/useClockIdentity \
    -readonly false
  method _c_./ptpRangeOverMac/useClockIdentity {t v} { $self _configure_relative ./ptpRangeOverMac -use_clock_identity $v }
  method _g_./ptpRangeOverMac/useClockIdentity {t} { $self _cget_relative ./ptpRangeOverMac -use_clock_identity }
  option -ptp_range_over_mac_priority1 \
    -configuremethod _c_./ptpRangeOverMac/priority1 \
    -cgetmethod _g_./ptpRangeOverMac/priority1 \
    -readonly false
  method _c_./ptpRangeOverMac/priority1 {t v} { $self _configure_relative ./ptpRangeOverMac -priority1 $v }
  method _g_./ptpRangeOverMac/priority1 {t} { $self _cget_relative ./ptpRangeOverMac -priority1 }
  # multiplier 
  method _m_ptp_range_over_mac_priority1 {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_priority1 }
  
  option -ptp_range_over_mac_use_alternate_master_flag \
    -configuremethod _c_./ptpRangeOverMac/useAlternateMasterFlag \
    -cgetmethod _g_./ptpRangeOverMac/useAlternateMasterFlag \
    -readonly false
  method _c_./ptpRangeOverMac/useAlternateMasterFlag {t v} { $self _configure_relative ./ptpRangeOverMac -use_alternate_master_flag $v }
  method _g_./ptpRangeOverMac/useAlternateMasterFlag {t} { $self _cget_relative ./ptpRangeOverMac -use_alternate_master_flag }
  option -ptp_range_over_mac_object_id \
    -configuremethod _c_./ptpRangeOverMac/objectId \
    -cgetmethod _g_./ptpRangeOverMac/objectId \
    -readonly false
  method _c_./ptpRangeOverMac/objectId {t v} { $self _configure_relative ./ptpRangeOverMac -object_id $v }
  method _g_./ptpRangeOverMac/objectId {t} { $self _cget_relative ./ptpRangeOverMac -object_id }
  # multiplier 
  method _m_ptp_range_over_mac_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_object_id }
  
  option -ptp_range_over_mac_delay_resp_receipt_timeout \
    -configuremethod _c_./ptpRangeOverMac/delayRespReceiptTimeout \
    -cgetmethod _g_./ptpRangeOverMac/delayRespReceiptTimeout \
    -readonly false
  method _c_./ptpRangeOverMac/delayRespReceiptTimeout {t v} { $self _configure_relative ./ptpRangeOverMac -delay_resp_receipt_timeout $v }
  method _g_./ptpRangeOverMac/delayRespReceiptTimeout {t} { $self _cget_relative ./ptpRangeOverMac -delay_resp_receipt_timeout }
  # multiplier 
  method _m_ptp_range_over_mac_delay_resp_receipt_timeout {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_delay_resp_receipt_timeout }
  
  option -ptp_range_over_mac_announce_frequency_traceable \
    -configuremethod _c_./ptpRangeOverMac/announceFrequencyTraceable \
    -cgetmethod _g_./ptpRangeOverMac/announceFrequencyTraceable \
    -readonly false
  method _c_./ptpRangeOverMac/announceFrequencyTraceable {t v} { $self _configure_relative ./ptpRangeOverMac -announce_frequency_traceable $v }
  method _g_./ptpRangeOverMac/announceFrequencyTraceable {t} { $self _cget_relative ./ptpRangeOverMac -announce_frequency_traceable }
  option -ptp_range_over_mac_priority2 \
    -configuremethod _c_./ptpRangeOverMac/priority2 \
    -cgetmethod _g_./ptpRangeOverMac/priority2 \
    -readonly false
  method _c_./ptpRangeOverMac/priority2 {t v} { $self _configure_relative ./ptpRangeOverMac -priority2 $v }
  method _g_./ptpRangeOverMac/priority2 {t} { $self _cget_relative ./ptpRangeOverMac -priority2 }
  # multiplier 
  method _m_ptp_range_over_mac_priority2 {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_priority2 }
  
  option -ptp_range_over_mac_announce_current_utc_offset_valid \
    -configuremethod _c_./ptpRangeOverMac/announceCurrentUtcOffsetValid \
    -cgetmethod _g_./ptpRangeOverMac/announceCurrentUtcOffsetValid \
    -readonly false
  method _c_./ptpRangeOverMac/announceCurrentUtcOffsetValid {t v} { $self _configure_relative ./ptpRangeOverMac -announce_current_utc_offset_valid $v }
  method _g_./ptpRangeOverMac/announceCurrentUtcOffsetValid {t} { $self _cget_relative ./ptpRangeOverMac -announce_current_utc_offset_valid }
  option -ptp_range_over_mac_client_mac_address \
    -configuremethod _c_./ptpRangeOverMac/clientMacAddress \
    -cgetmethod _g_./ptpRangeOverMac/clientMacAddress \
    -readonly false
  method _c_./ptpRangeOverMac/clientMacAddress {t v} { $self _configure_relative ./ptpRangeOverMac -client_mac_address $v }
  method _g_./ptpRangeOverMac/clientMacAddress {t} { $self _cget_relative ./ptpRangeOverMac -client_mac_address }
  # multiplier 
  method _m_ptp_range_over_mac_client_mac_address {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_client_mac_address }
  
  option -ptp_range_over_mac_time_source \
    -configuremethod _c_./ptpRangeOverMac/timeSource \
    -cgetmethod _g_./ptpRangeOverMac/timeSource \
    -readonly false
  method _c_./ptpRangeOverMac/timeSource {t v} { $self _configure_relative ./ptpRangeOverMac -time_source $v }
  method _g_./ptpRangeOverMac/timeSource {t} { $self _cget_relative ./ptpRangeOverMac -time_source }
  # multiplier 
  method _m_ptp_range_over_mac_time_source {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_time_source }
  
  option -ptp_range_over_mac_steps_removed \
    -configuremethod _c_./ptpRangeOverMac/stepsRemoved \
    -cgetmethod _g_./ptpRangeOverMac/stepsRemoved \
    -readonly false
  method _c_./ptpRangeOverMac/stepsRemoved {t v} { $self _configure_relative ./ptpRangeOverMac -steps_removed $v }
  method _g_./ptpRangeOverMac/stepsRemoved {t} { $self _cget_relative ./ptpRangeOverMac -steps_removed }
  # multiplier 
  method _m_ptp_range_over_mac_steps_removed {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_steps_removed }
  
  option -ptp_range_over_mac_clock_class \
    -configuremethod _c_./ptpRangeOverMac/clockClass \
    -cgetmethod _g_./ptpRangeOverMac/clockClass \
    -readonly false
  method _c_./ptpRangeOverMac/clockClass {t v} { $self _configure_relative ./ptpRangeOverMac -clock_class $v }
  method _g_./ptpRangeOverMac/clockClass {t} { $self _cget_relative ./ptpRangeOverMac -clock_class }
  # multiplier 
  method _m_ptp_range_over_mac_clock_class {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_clock_class }
  
  option -ptp_range_over_mac_request_attempts \
    -configuremethod _c_./ptpRangeOverMac/requestAttempts \
    -cgetmethod _g_./ptpRangeOverMac/requestAttempts \
    -readonly false
  method _c_./ptpRangeOverMac/requestAttempts {t v} { $self _configure_relative ./ptpRangeOverMac -request_attempts $v }
  method _g_./ptpRangeOverMac/requestAttempts {t} { $self _cget_relative ./ptpRangeOverMac -request_attempts }
  # multiplier 
  method _m_ptp_range_over_mac_request_attempts {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_request_attempts }
  
  option -ptp_range_over_mac_follow_up_bad_crc_rate \
    -configuremethod _c_./ptpRangeOverMac/followUpBadCrcRate \
    -cgetmethod _g_./ptpRangeOverMac/followUpBadCrcRate \
    -readonly false
  method _c_./ptpRangeOverMac/followUpBadCrcRate {t v} { $self _configure_relative ./ptpRangeOverMac -follow_up_bad_crc_rate $v }
  method _g_./ptpRangeOverMac/followUpBadCrcRate {t} { $self _cget_relative ./ptpRangeOverMac -follow_up_bad_crc_rate }
  # multiplier 
  method _m_ptp_range_over_mac_follow_up_bad_crc_rate {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_follow_up_bad_crc_rate }
  
  option -ptp_range_over_mac_delay_response_delay_insertion_rate \
    -configuremethod _c_./ptpRangeOverMac/delayResponseDelayInsertionRate \
    -cgetmethod _g_./ptpRangeOverMac/delayResponseDelayInsertionRate \
    -readonly false
  method _c_./ptpRangeOverMac/delayResponseDelayInsertionRate {t v} { $self _configure_relative ./ptpRangeOverMac -delay_response_delay_insertion_rate $v }
  method _g_./ptpRangeOverMac/delayResponseDelayInsertionRate {t} { $self _cget_relative ./ptpRangeOverMac -delay_response_delay_insertion_rate }
  # multiplier 
  method _m_ptp_range_over_mac_delay_response_delay_insertion_rate {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_delay_response_delay_insertion_rate }
  
  option -ptp_range_over_mac_log_sync_interval \
    -configuremethod _c_./ptpRangeOverMac/logSyncInterval \
    -cgetmethod _g_./ptpRangeOverMac/logSyncInterval \
    -readonly false
  method _c_./ptpRangeOverMac/logSyncInterval {t v} { $self _configure_relative ./ptpRangeOverMac -log_sync_interval $v }
  method _g_./ptpRangeOverMac/logSyncInterval {t} { $self _cget_relative ./ptpRangeOverMac -log_sync_interval }
  # multiplier 
  method _m_ptp_range_over_mac_log_sync_interval {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_log_sync_interval }
  
  option -ptp_range_over_mac_master_count \
    -configuremethod _c_./ptpRangeOverMac/masterCount \
    -cgetmethod _g_./ptpRangeOverMac/masterCount \
    -readonly false
  method _c_./ptpRangeOverMac/masterCount {t v} { $self _configure_relative ./ptpRangeOverMac -master_count $v }
  method _g_./ptpRangeOverMac/masterCount {t} { $self _cget_relative ./ptpRangeOverMac -master_count }
  # multiplier 
  method _m_ptp_range_over_mac_master_count {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_master_count }
  
  option -ptp_range_over_mac_residence_time \
    -configuremethod _c_./ptpRangeOverMac/residenceTime \
    -cgetmethod _g_./ptpRangeOverMac/residenceTime \
    -readonly false
  method _c_./ptpRangeOverMac/residenceTime {t v} { $self _configure_relative ./ptpRangeOverMac -residence_time $v }
  method _g_./ptpRangeOverMac/residenceTime {t} { $self _cget_relative ./ptpRangeOverMac -residence_time }
  # multiplier 
  method _m_ptp_range_over_mac_residence_time {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_residence_time }
  
  option -ptp_range_over_mac_signal_interval \
    -configuremethod _c_./ptpRangeOverMac/signalInterval \
    -cgetmethod _g_./ptpRangeOverMac/signalInterval \
    -readonly false
  method _c_./ptpRangeOverMac/signalInterval {t v} { $self _configure_relative ./ptpRangeOverMac -signal_interval $v }
  method _g_./ptpRangeOverMac/signalInterval {t} { $self _cget_relative ./ptpRangeOverMac -signal_interval }
  # multiplier 
  method _m_ptp_range_over_mac_signal_interval {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_signal_interval }
  
  option -ptp_range_over_mac_delay_mechanism \
    -configuremethod _c_./ptpRangeOverMac/delayMechanism \
    -cgetmethod _g_./ptpRangeOverMac/delayMechanism \
    -readonly false
  method _c_./ptpRangeOverMac/delayMechanism {t v} { $self _configure_relative ./ptpRangeOverMac -delay_mechanism $v }
  method _g_./ptpRangeOverMac/delayMechanism {t} { $self _cget_relative ./ptpRangeOverMac -delay_mechanism }
  # multiplier 
  method _m_ptp_range_over_mac_delay_mechanism {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_delay_mechanism }
  
  option -ptp_range_over_mac_strict_grant \
    -configuremethod _c_./ptpRangeOverMac/strictGrant \
    -cgetmethod _g_./ptpRangeOverMac/strictGrant \
    -readonly false
  method _c_./ptpRangeOverMac/strictGrant {t v} { $self _configure_relative ./ptpRangeOverMac -strict_grant $v }
  method _g_./ptpRangeOverMac/strictGrant {t} { $self _cget_relative ./ptpRangeOverMac -strict_grant }
  option -ptp_range_over_mac_sync_drop_rate \
    -configuremethod _c_./ptpRangeOverMac/syncDropRate \
    -cgetmethod _g_./ptpRangeOverMac/syncDropRate \
    -readonly false
  method _c_./ptpRangeOverMac/syncDropRate {t v} { $self _configure_relative ./ptpRangeOverMac -sync_drop_rate $v }
  method _g_./ptpRangeOverMac/syncDropRate {t} { $self _cget_relative ./ptpRangeOverMac -sync_drop_rate }
  # multiplier 
  method _m_ptp_range_over_mac_sync_drop_rate {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_sync_drop_rate }
  
  option -ptp_range_over_mac_drop_signal_req_sync \
    -configuremethod _c_./ptpRangeOverMac/dropSignalReqSync \
    -cgetmethod _g_./ptpRangeOverMac/dropSignalReqSync \
    -readonly false
  method _c_./ptpRangeOverMac/dropSignalReqSync {t v} { $self _configure_relative ./ptpRangeOverMac -drop_signal_req_sync $v }
  method _g_./ptpRangeOverMac/dropSignalReqSync {t} { $self _cget_relative ./ptpRangeOverMac -drop_signal_req_sync }
  option -ptp_range_over_mac_clock_increment \
    -configuremethod _c_./ptpRangeOverMac/clockIncrement \
    -cgetmethod _g_./ptpRangeOverMac/clockIncrement \
    -readonly false
  method _c_./ptpRangeOverMac/clockIncrement {t v} { $self _configure_relative ./ptpRangeOverMac -clock_increment $v }
  method _g_./ptpRangeOverMac/clockIncrement {t} { $self _cget_relative ./ptpRangeOverMac -clock_increment }
  # multiplier 
  method _m_ptp_range_over_mac_clock_increment {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_clock_increment }
  
  option -ptp_range_over_mac_announce_ptp_timescale \
    -configuremethod _c_./ptpRangeOverMac/announcePtpTimescale \
    -cgetmethod _g_./ptpRangeOverMac/announcePtpTimescale \
    -readonly false
  method _c_./ptpRangeOverMac/announcePtpTimescale {t v} { $self _configure_relative ./ptpRangeOverMac -announce_ptp_timescale $v }
  method _g_./ptpRangeOverMac/announcePtpTimescale {t} { $self _cget_relative ./ptpRangeOverMac -announce_ptp_timescale }
  option -ptp_range_over_mac_signal_unicast_handling \
    -configuremethod _c_./ptpRangeOverMac/signalUnicastHandling \
    -cgetmethod _g_./ptpRangeOverMac/signalUnicastHandling \
    -readonly false
  method _c_./ptpRangeOverMac/signalUnicastHandling {t v} { $self _configure_relative ./ptpRangeOverMac -signal_unicast_handling $v }
  method _g_./ptpRangeOverMac/signalUnicastHandling {t} { $self _cget_relative ./ptpRangeOverMac -signal_unicast_handling }
  # multiplier 
  method _m_ptp_range_over_mac_signal_unicast_handling {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_signal_unicast_handling }
  
  option -ptp_range_over_mac_enabled \
    -configuremethod _c_./ptpRangeOverMac/enabled \
    -cgetmethod _g_./ptpRangeOverMac/enabled \
    -readonly false
  method _c_./ptpRangeOverMac/enabled {t v} { $self _configure_relative ./ptpRangeOverMac -enabled $v }
  method _g_./ptpRangeOverMac/enabled {t} { $self _cget_relative ./ptpRangeOverMac -enabled }
  option -ptp_range_over_mac_timestamp_offset \
    -configuremethod _c_./ptpRangeOverMac/timestampOffset \
    -cgetmethod _g_./ptpRangeOverMac/timestampOffset \
    -readonly false
  method _c_./ptpRangeOverMac/timestampOffset {t v} { $self _configure_relative ./ptpRangeOverMac -timestamp_offset $v }
  method _g_./ptpRangeOverMac/timestampOffset {t} { $self _cget_relative ./ptpRangeOverMac -timestamp_offset }
  # multiplier 
  method _m_ptp_range_over_mac_timestamp_offset {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_timestamp_offset }
  
  option -ptp_range_over_mac_master_ip_increment_by \
    -configuremethod _c_./ptpRangeOverMac/masterIpIncrementBy \
    -cgetmethod _g_./ptpRangeOverMac/masterIpIncrementBy \
    -readonly false
  method _c_./ptpRangeOverMac/masterIpIncrementBy {t v} { $self _configure_relative ./ptpRangeOverMac -master_ip_increment_by $v }
  method _g_./ptpRangeOverMac/masterIpIncrementBy {t} { $self _cget_relative ./ptpRangeOverMac -master_ip_increment_by }
  # multiplier 
  method _m_ptp_range_over_mac_master_ip_increment_by {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_master_ip_increment_by }
  
  option -ptp_range_over_mac_request_interval \
    -configuremethod _c_./ptpRangeOverMac/requestInterval \
    -cgetmethod _g_./ptpRangeOverMac/requestInterval \
    -readonly false
  method _c_./ptpRangeOverMac/requestInterval {t v} { $self _configure_relative ./ptpRangeOverMac -request_interval $v }
  method _g_./ptpRangeOverMac/requestInterval {t} { $self _cget_relative ./ptpRangeOverMac -request_interval }
  # multiplier 
  method _m_ptp_range_over_mac_request_interval {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_request_interval }
  
  option -ptp_range_over_mac_ip_tos \
    -configuremethod _c_./ptpRangeOverMac/ipTos \
    -cgetmethod _g_./ptpRangeOverMac/ipTos \
    -readonly false
  method _c_./ptpRangeOverMac/ipTos {t v} { $self _configure_relative ./ptpRangeOverMac -ip_tos $v }
  method _g_./ptpRangeOverMac/ipTos {t} { $self _cget_relative ./ptpRangeOverMac -ip_tos }
  # multiplier 
  method _m_ptp_range_over_mac_ip_tos {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_ip_tos }
  
  option -ptp_range_over_mac_request_holddown \
    -configuremethod _c_./ptpRangeOverMac/requestHolddown \
    -cgetmethod _g_./ptpRangeOverMac/requestHolddown \
    -readonly false
  method _c_./ptpRangeOverMac/requestHolddown {t v} { $self _configure_relative ./ptpRangeOverMac -request_holddown $v }
  method _g_./ptpRangeOverMac/requestHolddown {t} { $self _cget_relative ./ptpRangeOverMac -request_holddown }
  # multiplier 
  method _m_ptp_range_over_mac_request_holddown {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_request_holddown }
  
  option -ptp_range_over_mac_client_mac_increment_by \
    -configuremethod _c_./ptpRangeOverMac/clientMacIncrementBy \
    -cgetmethod _g_./ptpRangeOverMac/clientMacIncrementBy \
    -readonly false
  method _c_./ptpRangeOverMac/clientMacIncrementBy {t v} { $self _configure_relative ./ptpRangeOverMac -client_mac_increment_by $v }
  method _g_./ptpRangeOverMac/clientMacIncrementBy {t} { $self _cget_relative ./ptpRangeOverMac -client_mac_increment_by }
  # multiplier 
  method _m_ptp_range_over_mac_client_mac_increment_by {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_client_mac_increment_by }
  
  option -ptp_range_over_mac_name \
    -configuremethod _c_./ptpRangeOverMac/name \
    -cgetmethod _g_./ptpRangeOverMac/name \
    -readonly false
  method _c_./ptpRangeOverMac/name {t v} { $self _configure_relative ./ptpRangeOverMac -name $v }
  method _g_./ptpRangeOverMac/name {t} { $self _cget_relative ./ptpRangeOverMac -name }
  # multiplier 
  method _m_ptp_range_over_mac_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_name }
  
  option -ptp_range_over_mac_drop_signal_req_announce \
    -configuremethod _c_./ptpRangeOverMac/dropSignalReqAnnounce \
    -cgetmethod _g_./ptpRangeOverMac/dropSignalReqAnnounce \
    -readonly false
  method _c_./ptpRangeOverMac/dropSignalReqAnnounce {t v} { $self _configure_relative ./ptpRangeOverMac -drop_signal_req_announce $v }
  method _g_./ptpRangeOverMac/dropSignalReqAnnounce {t} { $self _cget_relative ./ptpRangeOverMac -drop_signal_req_announce }
  option -ptp_range_over_mac_master_ip_address \
    -configuremethod _c_./ptpRangeOverMac/masterIpAddress \
    -cgetmethod _g_./ptpRangeOverMac/masterIpAddress \
    -readonly false
  method _c_./ptpRangeOverMac/masterIpAddress {t v} { $self _configure_relative ./ptpRangeOverMac -master_ip_address $v }
  method _g_./ptpRangeOverMac/masterIpAddress {t} { $self _cget_relative ./ptpRangeOverMac -master_ip_address }
  # multiplier 
  method _m_ptp_range_over_mac_master_ip_address {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_master_ip_address }
  
  option -ptp_range_over_mac_first_clock \
    -configuremethod _c_./ptpRangeOverMac/firstClock \
    -cgetmethod _g_./ptpRangeOverMac/firstClock \
    -readonly false
  method _c_./ptpRangeOverMac/firstClock {t v} { $self _configure_relative ./ptpRangeOverMac -first_clock $v }
  method _g_./ptpRangeOverMac/firstClock {t} { $self _cget_relative ./ptpRangeOverMac -first_clock }
  # multiplier 
  method _m_ptp_range_over_mac_first_clock {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_first_clock }
  
  option -ptp_range_over_mac_master_mac_increment_by \
    -configuremethod _c_./ptpRangeOverMac/masterMacIncrementBy \
    -cgetmethod _g_./ptpRangeOverMac/masterMacIncrementBy \
    -readonly false
  method _c_./ptpRangeOverMac/masterMacIncrementBy {t v} { $self _configure_relative ./ptpRangeOverMac -master_mac_increment_by $v }
  method _g_./ptpRangeOverMac/masterMacIncrementBy {t} { $self _cget_relative ./ptpRangeOverMac -master_mac_increment_by }
  # multiplier 
  method _m_ptp_range_over_mac_master_mac_increment_by {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_master_mac_increment_by }
  
  option -ptp_range_over_mac_send_cancel_tlv \
    -configuremethod _c_./ptpRangeOverMac/sendCancelTlv \
    -cgetmethod _g_./ptpRangeOverMac/sendCancelTlv \
    -readonly false
  method _c_./ptpRangeOverMac/sendCancelTlv {t v} { $self _configure_relative ./ptpRangeOverMac -send_cancel_tlv $v }
  method _g_./ptpRangeOverMac/sendCancelTlv {t} { $self _cget_relative ./ptpRangeOverMac -send_cancel_tlv }
  option -ptp_range_over_mac_port_number \
    -configuremethod _c_./ptpRangeOverMac/portNumber \
    -cgetmethod _g_./ptpRangeOverMac/portNumber \
    -readonly false
  method _c_./ptpRangeOverMac/portNumber {t v} { $self _configure_relative ./ptpRangeOverMac -port_number $v }
  method _g_./ptpRangeOverMac/portNumber {t} { $self _cget_relative ./ptpRangeOverMac -port_number }
  # multiplier 
  method _m_ptp_range_over_mac_port_number {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_port_number }
  
  option -ptp_range_over_mac_client_ip_address \
    -configuremethod _c_./ptpRangeOverMac/clientIpAddress \
    -cgetmethod _g_./ptpRangeOverMac/clientIpAddress \
    -readonly false
  method _c_./ptpRangeOverMac/clientIpAddress {t v} { $self _configure_relative ./ptpRangeOverMac -client_ip_address $v }
  method _g_./ptpRangeOverMac/clientIpAddress {t} { $self _cget_relative ./ptpRangeOverMac -client_ip_address }
  # multiplier 
  method _m_ptp_range_over_mac_client_ip_address {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_client_ip_address }
  
  option -ptp_range_over_mac_announce_leap59 \
    -configuremethod _c_./ptpRangeOverMac/announceLeap59 \
    -cgetmethod _g_./ptpRangeOverMac/announceLeap59 \
    -readonly false
  method _c_./ptpRangeOverMac/announceLeap59 {t v} { $self _configure_relative ./ptpRangeOverMac -announce_leap59 $v }
  method _g_./ptpRangeOverMac/announceLeap59 {t} { $self _cget_relative ./ptpRangeOverMac -announce_leap59 }
  option -ptp_range_over_mac_send_announce_tlv \
    -configuremethod _c_./ptpRangeOverMac/sendAnnounceTlv \
    -cgetmethod _g_./ptpRangeOverMac/sendAnnounceTlv \
    -readonly false
  method _c_./ptpRangeOverMac/sendAnnounceTlv {t v} { $self _configure_relative ./ptpRangeOverMac -send_announce_tlv $v }
  method _g_./ptpRangeOverMac/sendAnnounceTlv {t} { $self _cget_relative ./ptpRangeOverMac -send_announce_tlv }
  option -ptp_range_over_mac_sync_receipt_timeout \
    -configuremethod _c_./ptpRangeOverMac/syncReceiptTimeout \
    -cgetmethod _g_./ptpRangeOverMac/syncReceiptTimeout \
    -readonly false
  method _c_./ptpRangeOverMac/syncReceiptTimeout {t v} { $self _configure_relative ./ptpRangeOverMac -sync_receipt_timeout $v }
  method _g_./ptpRangeOverMac/syncReceiptTimeout {t} { $self _cget_relative ./ptpRangeOverMac -sync_receipt_timeout }
  # multiplier 
  method _m_ptp_range_over_mac_sync_receipt_timeout {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_sync_receipt_timeout }
  
  option -ptp_range_over_mac_announce_leap61 \
    -configuremethod _c_./ptpRangeOverMac/announceLeap61 \
    -cgetmethod _g_./ptpRangeOverMac/announceLeap61 \
    -readonly false
  method _c_./ptpRangeOverMac/announceLeap61 {t v} { $self _configure_relative ./ptpRangeOverMac -announce_leap61 $v }
  method _g_./ptpRangeOverMac/announceLeap61 {t} { $self _cget_relative ./ptpRangeOverMac -announce_leap61 }
  option -ptp_range_over_mac_grant_delay_resp_duration_interval \
    -configuremethod _c_./ptpRangeOverMac/grantDelayRespDurationInterval \
    -cgetmethod _g_./ptpRangeOverMac/grantDelayRespDurationInterval \
    -readonly false
  method _c_./ptpRangeOverMac/grantDelayRespDurationInterval {t v} { $self _configure_relative ./ptpRangeOverMac -grant_delay_resp_duration_interval $v }
  method _g_./ptpRangeOverMac/grantDelayRespDurationInterval {t} { $self _cget_relative ./ptpRangeOverMac -grant_delay_resp_duration_interval }
  # multiplier 
  method _m_ptp_range_over_mac_grant_delay_resp_duration_interval {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_grant_delay_resp_duration_interval }
  
  option -ptp_range_over_mac_timestamp_offset_variation \
    -configuremethod _c_./ptpRangeOverMac/timestampOffsetVariation \
    -cgetmethod _g_./ptpRangeOverMac/timestampOffsetVariation \
    -readonly false
  method _c_./ptpRangeOverMac/timestampOffsetVariation {t v} { $self _configure_relative ./ptpRangeOverMac -timestamp_offset_variation $v }
  method _g_./ptpRangeOverMac/timestampOffsetVariation {t} { $self _cget_relative ./ptpRangeOverMac -timestamp_offset_variation }
  # multiplier 
  method _m_ptp_range_over_mac_timestamp_offset_variation {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_timestamp_offset_variation }
  
  option -ptp_range_over_mac_follow_up_drop_rate \
    -configuremethod _c_./ptpRangeOverMac/followUpDropRate \
    -cgetmethod _g_./ptpRangeOverMac/followUpDropRate \
    -readonly false
  method _c_./ptpRangeOverMac/followUpDropRate {t v} { $self _configure_relative ./ptpRangeOverMac -follow_up_drop_rate $v }
  method _g_./ptpRangeOverMac/followUpDropRate {t} { $self _cget_relative ./ptpRangeOverMac -follow_up_drop_rate }
  # multiplier 
  method _m_ptp_range_over_mac_follow_up_drop_rate {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_follow_up_drop_rate }
  
  option -ptp_range_over_mac_master_mac_address \
    -configuremethod _c_./ptpRangeOverMac/masterMacAddress \
    -cgetmethod _g_./ptpRangeOverMac/masterMacAddress \
    -readonly false
  method _c_./ptpRangeOverMac/masterMacAddress {t v} { $self _configure_relative ./ptpRangeOverMac -master_mac_address $v }
  method _g_./ptpRangeOverMac/masterMacAddress {t} { $self _cget_relative ./ptpRangeOverMac -master_mac_address }
  # multiplier 
  method _m_ptp_range_over_mac_master_mac_address {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_master_mac_address }
  
  option -ptp_range_over_mac_drop_signal_req_delay_resp \
    -configuremethod _c_./ptpRangeOverMac/dropSignalReqDelayResp \
    -cgetmethod _g_./ptpRangeOverMac/dropSignalReqDelayResp \
    -readonly false
  method _c_./ptpRangeOverMac/dropSignalReqDelayResp {t v} { $self _configure_relative ./ptpRangeOverMac -drop_signal_req_delay_resp $v }
  method _g_./ptpRangeOverMac/dropSignalReqDelayResp {t} { $self _cget_relative ./ptpRangeOverMac -drop_signal_req_delay_resp }
  option -ptp_range_over_mac_grant_sync_duration_interval \
    -configuremethod _c_./ptpRangeOverMac/grantSyncDurationInterval \
    -cgetmethod _g_./ptpRangeOverMac/grantSyncDurationInterval \
    -readonly false
  method _c_./ptpRangeOverMac/grantSyncDurationInterval {t v} { $self _configure_relative ./ptpRangeOverMac -grant_sync_duration_interval $v }
  method _g_./ptpRangeOverMac/grantSyncDurationInterval {t} { $self _cget_relative ./ptpRangeOverMac -grant_sync_duration_interval }
  # multiplier 
  method _m_ptp_range_over_mac_grant_sync_duration_interval {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_grant_sync_duration_interval }
  
  option -ptp_range_over_mac_learn_port_id \
    -configuremethod _c_./ptpRangeOverMac/learnPortId \
    -cgetmethod _g_./ptpRangeOverMac/learnPortId \
    -readonly false
  method _c_./ptpRangeOverMac/learnPortId {t v} { $self _configure_relative ./ptpRangeOverMac -learn_port_id $v }
  method _g_./ptpRangeOverMac/learnPortId {t} { $self _cget_relative ./ptpRangeOverMac -learn_port_id }
  option -ptp_range_over_mac_delay_response_delay \
    -configuremethod _c_./ptpRangeOverMac/delayResponseDelay \
    -cgetmethod _g_./ptpRangeOverMac/delayResponseDelay \
    -readonly false
  method _c_./ptpRangeOverMac/delayResponseDelay {t v} { $self _configure_relative ./ptpRangeOverMac -delay_response_delay $v }
  method _g_./ptpRangeOverMac/delayResponseDelay {t} { $self _cget_relative ./ptpRangeOverMac -delay_response_delay }
  # multiplier 
  method _m_ptp_range_over_mac_delay_response_delay {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_delay_response_delay }
  
  option -ptp_range_over_mac_grant_unicast_duration_interval \
    -configuremethod _c_./ptpRangeOverMac/grantUnicastDurationInterval \
    -cgetmethod _g_./ptpRangeOverMac/grantUnicastDurationInterval \
    -readonly false
  method _c_./ptpRangeOverMac/grantUnicastDurationInterval {t v} { $self _configure_relative ./ptpRangeOverMac -grant_unicast_duration_interval $v }
  method _g_./ptpRangeOverMac/grantUnicastDurationInterval {t} { $self _cget_relative ./ptpRangeOverMac -grant_unicast_duration_interval }
  # multiplier 
  method _m_ptp_range_over_mac_grant_unicast_duration_interval {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_grant_unicast_duration_interval }
  
  option -ptp_range_over_mac_follow_up_delay_insertion_rate \
    -configuremethod _c_./ptpRangeOverMac/followUpDelayInsertionRate \
    -cgetmethod _g_./ptpRangeOverMac/followUpDelayInsertionRate \
    -readonly false
  method _c_./ptpRangeOverMac/followUpDelayInsertionRate {t v} { $self _configure_relative ./ptpRangeOverMac -follow_up_delay_insertion_rate $v }
  method _g_./ptpRangeOverMac/followUpDelayInsertionRate {t} { $self _cget_relative ./ptpRangeOverMac -follow_up_delay_insertion_rate }
  # multiplier 
  method _m_ptp_range_over_mac_follow_up_delay_insertion_rate {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_follow_up_delay_insertion_rate }
  
  option -ptp_range_over_mac_log_delay_req_interval \
    -configuremethod _c_./ptpRangeOverMac/logDelayReqInterval \
    -cgetmethod _g_./ptpRangeOverMac/logDelayReqInterval \
    -readonly false
  method _c_./ptpRangeOverMac/logDelayReqInterval {t v} { $self _configure_relative ./ptpRangeOverMac -log_delay_req_interval $v }
  method _g_./ptpRangeOverMac/logDelayReqInterval {t} { $self _cget_relative ./ptpRangeOverMac -log_delay_req_interval }
  # multiplier 
  method _m_ptp_range_over_mac_log_delay_req_interval {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_log_delay_req_interval }
  
  option -ptp_range_over_mac_clock_accuracy \
    -configuremethod _c_./ptpRangeOverMac/clockAccuracy \
    -cgetmethod _g_./ptpRangeOverMac/clockAccuracy \
    -readonly false
  method _c_./ptpRangeOverMac/clockAccuracy {t v} { $self _configure_relative ./ptpRangeOverMac -clock_accuracy $v }
  method _g_./ptpRangeOverMac/clockAccuracy {t} { $self _cget_relative ./ptpRangeOverMac -clock_accuracy }
  # multiplier 
  method _m_ptp_range_over_mac_clock_accuracy {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_clock_accuracy }
  
  option -ptp_range_over_mac_client_count \
    -configuremethod _c_./ptpRangeOverMac/clientCount \
    -cgetmethod _g_./ptpRangeOverMac/clientCount \
    -readonly false
  method _c_./ptpRangeOverMac/clientCount {t v} { $self _configure_relative ./ptpRangeOverMac -client_count $v }
  method _g_./ptpRangeOverMac/clientCount {t} { $self _cget_relative ./ptpRangeOverMac -client_count }
  # multiplier 
  method _m_ptp_range_over_mac_client_count {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_client_count }
  
  option -ptp_range_over_mac_announce_time_traceable \
    -configuremethod _c_./ptpRangeOverMac/announceTimeTraceable \
    -cgetmethod _g_./ptpRangeOverMac/announceTimeTraceable \
    -readonly false
  method _c_./ptpRangeOverMac/announceTimeTraceable {t v} { $self _configure_relative ./ptpRangeOverMac -announce_time_traceable $v }
  method _g_./ptpRangeOverMac/announceTimeTraceable {t} { $self _cget_relative ./ptpRangeOverMac -announce_time_traceable }
  option -ptp_range_over_mac_step_mode \
    -configuremethod _c_./ptpRangeOverMac/stepMode \
    -cgetmethod _g_./ptpRangeOverMac/stepMode \
    -readonly false
  method _c_./ptpRangeOverMac/stepMode {t v} { $self _configure_relative ./ptpRangeOverMac -step_mode $v }
  method _g_./ptpRangeOverMac/stepMode {t} { $self _cget_relative ./ptpRangeOverMac -step_mode }
  # multiplier 
  method _m_ptp_range_over_mac_step_mode {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_step_mode }
  
  option -ptp_range_over_mac_master_ip_increment_inter_entity \
    -configuremethod _c_./ptpRangeOverMac/masterIpIncrementInterEntity \
    -cgetmethod _g_./ptpRangeOverMac/masterIpIncrementInterEntity \
    -readonly false
  method _c_./ptpRangeOverMac/masterIpIncrementInterEntity {t v} { $self _configure_relative ./ptpRangeOverMac -master_ip_increment_inter_entity $v }
  method _g_./ptpRangeOverMac/masterIpIncrementInterEntity {t} { $self _cget_relative ./ptpRangeOverMac -master_ip_increment_inter_entity }
  # multiplier 
  method _m_ptp_range_over_mac_master_ip_increment_inter_entity {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -ptp_range_over_mac_master_ip_increment_inter_entity }
  
  option -ptp_range_over_mac_delay_resp_drop_rate \
    -configuremethod _c_./ptpRangeOverMac/delayRespDropRate \
    -cgetmethod _g_./ptpRangeOverMac/delayRespDropRate \
    -readonly false
  method _c_./ptpRangeOverMac/delayRespDropRate {t v} { $self _configure_relative ./ptpRangeOverMac -delay_resp_drop_rate $v }
  method _g_./ptpRangeOverMac/delayRespDropRate {t} { $self _cget_relative ./ptpRangeOverMac -delay_resp_drop_rate }
  # multiplier 
  method _m_ptp_range_over_mac_delay_resp_drop_rate {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_delay_resp_drop_rate }
  
  option -ptp_range_over_mac_announce_receipt_timeout \
    -configuremethod _c_./ptpRangeOverMac/announceReceiptTimeout \
    -cgetmethod _g_./ptpRangeOverMac/announceReceiptTimeout \
    -readonly false
  method _c_./ptpRangeOverMac/announceReceiptTimeout {t v} { $self _configure_relative ./ptpRangeOverMac -announce_receipt_timeout $v }
  method _g_./ptpRangeOverMac/announceReceiptTimeout {t} { $self _cget_relative ./ptpRangeOverMac -announce_receipt_timeout }
  # multiplier 
  method _m_ptp_range_over_mac_announce_receipt_timeout {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_announce_receipt_timeout }
  
  option -ptp_range_over_mac_rx_calibration \
    -configuremethod _c_./ptpRangeOverMac/rxCalibration \
    -cgetmethod _g_./ptpRangeOverMac/rxCalibration \
    -readonly false
  method _c_./ptpRangeOverMac/rxCalibration {t v} { $self _configure_relative ./ptpRangeOverMac -rx_calibration $v }
  method _g_./ptpRangeOverMac/rxCalibration {t} { $self _cget_relative ./ptpRangeOverMac -rx_calibration }
  # multiplier 
  method _m_ptp_range_over_mac_rx_calibration {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_rx_calibration }
  
  option -ptp_range_over_mac_tx_calibration \
    -configuremethod _c_./ptpRangeOverMac/txCalibration \
    -cgetmethod _g_./ptpRangeOverMac/txCalibration \
    -readonly false
  method _c_./ptpRangeOverMac/txCalibration {t v} { $self _configure_relative ./ptpRangeOverMac -tx_calibration $v }
  method _g_./ptpRangeOverMac/txCalibration {t} { $self _cget_relative ./ptpRangeOverMac -tx_calibration }
  # multiplier 
  method _m_ptp_range_over_mac_tx_calibration {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_tx_calibration }
  
  option -ptp_range_over_mac_log_announce_interval \
    -configuremethod _c_./ptpRangeOverMac/logAnnounceInterval \
    -cgetmethod _g_./ptpRangeOverMac/logAnnounceInterval \
    -readonly false
  method _c_./ptpRangeOverMac/logAnnounceInterval {t v} { $self _configure_relative ./ptpRangeOverMac -log_announce_interval $v }
  method _g_./ptpRangeOverMac/logAnnounceInterval {t} { $self _cget_relative ./ptpRangeOverMac -log_announce_interval }
  # multiplier 
  method _m_ptp_range_over_mac_log_announce_interval {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -ptp_range_over_mac_log_announce_interval }
  
  option -vlan_range_inner_first_id \
    -configuremethod _c_./vlanRange/innerFirstId \
    -cgetmethod _g_./vlanRange/innerFirstId \
    -readonly false
  method _c_./vlanRange/innerFirstId {t v} { $self _configure_relative ./vlanRange -inner_first_id $v }
  method _g_./vlanRange/innerFirstId {t} { $self _cget_relative ./vlanRange -inner_first_id }
  # multiplier 
  method _m_vlan_range_inner_first_id {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_inner_first_id }
  
  option -vlan_range_inner_increment \
    -configuremethod _c_./vlanRange/innerIncrement \
    -cgetmethod _g_./vlanRange/innerIncrement \
    -readonly false
  method _c_./vlanRange/innerIncrement {t v} { $self _configure_relative ./vlanRange -inner_increment $v }
  method _g_./vlanRange/innerIncrement {t} { $self _cget_relative ./vlanRange -inner_increment }
  # multiplier 
  method _m_vlan_range_inner_increment {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_inner_increment }
  
  option -vlan_range_enabled \
    -configuremethod _c_./vlanRange/enabled \
    -cgetmethod _g_./vlanRange/enabled \
    -readonly false
  method _c_./vlanRange/enabled {t v} { $self _configure_relative ./vlanRange -enabled $v }
  method _g_./vlanRange/enabled {t} { $self _cget_relative ./vlanRange -enabled }
  option -vlan_range_unique_count \
    -configuremethod _c_./vlanRange/uniqueCount \
    -cgetmethod _g_./vlanRange/uniqueCount \
    -readonly false
  method _c_./vlanRange/uniqueCount {t v} { $self _configure_relative ./vlanRange -unique_count $v }
  method _g_./vlanRange/uniqueCount {t} { $self _cget_relative ./vlanRange -unique_count }
  # multiplier 
  method _m_vlan_range_unique_count {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_unique_count }
  
  option -vlan_range_name \
    -configuremethod _c_./vlanRange/name \
    -cgetmethod _g_./vlanRange/name \
    -readonly false
  method _c_./vlanRange/name {t v} { $self _configure_relative ./vlanRange -name $v }
  method _g_./vlanRange/name {t} { $self _cget_relative ./vlanRange -name }
  # multiplier 
  method _m_vlan_range_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -vlan_range_name }
  
  option -vlan_range_increment_step \
    -configuremethod _c_./vlanRange/incrementStep \
    -cgetmethod _g_./vlanRange/incrementStep \
    -readonly false
  method _c_./vlanRange/incrementStep {t v} { $self _configure_relative ./vlanRange -increment_step $v }
  method _g_./vlanRange/incrementStep {t} { $self _cget_relative ./vlanRange -increment_step }
  # multiplier 
  method _m_vlan_range_increment_step {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_increment_step }
  
  option -vlan_range_tpid \
    -configuremethod _c_./vlanRange/tpid \
    -cgetmethod _g_./vlanRange/tpid \
    -readonly false
  method _c_./vlanRange/tpid {t v} { $self _configure_relative ./vlanRange -tpid $v }
  method _g_./vlanRange/tpid {t} { $self _cget_relative ./vlanRange -tpid }
  # multiplier 
  method _m_vlan_range_tpid {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -vlan_range_tpid }
  
  option -vlan_range_priority \
    -configuremethod _c_./vlanRange/priority \
    -cgetmethod _g_./vlanRange/priority \
    -readonly false
  method _c_./vlanRange/priority {t v} { $self _configure_relative ./vlanRange -priority $v }
  method _g_./vlanRange/priority {t} { $self _cget_relative ./vlanRange -priority }
  # multiplier 
  method _m_vlan_range_priority {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_priority }
  
  option -vlan_range_inner_enable \
    -configuremethod _c_./vlanRange/innerEnable \
    -cgetmethod _g_./vlanRange/innerEnable \
    -readonly false
  method _c_./vlanRange/innerEnable {t v} { $self _configure_relative ./vlanRange -inner_enable $v }
  method _g_./vlanRange/innerEnable {t} { $self _cget_relative ./vlanRange -inner_enable }
  option -vlan_range_object_id \
    -configuremethod _c_./vlanRange/objectId \
    -cgetmethod _g_./vlanRange/objectId \
    -readonly false
  method _c_./vlanRange/objectId {t v} { $self _configure_relative ./vlanRange -object_id $v }
  method _g_./vlanRange/objectId {t} { $self _cget_relative ./vlanRange -object_id }
  # multiplier 
  method _m_vlan_range_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -vlan_range_object_id }
  
  option -vlan_range_inner_unique_count \
    -configuremethod _c_./vlanRange/innerUniqueCount \
    -cgetmethod _g_./vlanRange/innerUniqueCount \
    -readonly false
  method _c_./vlanRange/innerUniqueCount {t v} { $self _configure_relative ./vlanRange -inner_unique_count $v }
  method _g_./vlanRange/innerUniqueCount {t} { $self _cget_relative ./vlanRange -inner_unique_count }
  # multiplier 
  method _m_vlan_range_inner_unique_count {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_inner_unique_count }
  
  option -vlan_range_inner_tpid \
    -configuremethod _c_./vlanRange/innerTpid \
    -cgetmethod _g_./vlanRange/innerTpid \
    -readonly false
  method _c_./vlanRange/innerTpid {t v} { $self _configure_relative ./vlanRange -inner_tpid $v }
  method _g_./vlanRange/innerTpid {t} { $self _cget_relative ./vlanRange -inner_tpid }
  # multiplier 
  method _m_vlan_range_inner_tpid {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -vlan_range_inner_tpid }
  
  option -vlan_range_first_id \
    -configuremethod _c_./vlanRange/firstId \
    -cgetmethod _g_./vlanRange/firstId \
    -readonly false
  method _c_./vlanRange/firstId {t v} { $self _configure_relative ./vlanRange -first_id $v }
  method _g_./vlanRange/firstId {t} { $self _cget_relative ./vlanRange -first_id }
  # multiplier 
  method _m_vlan_range_first_id {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_first_id }
  
  option -vlan_range_increment \
    -configuremethod _c_./vlanRange/increment \
    -cgetmethod _g_./vlanRange/increment \
    -readonly false
  method _c_./vlanRange/increment {t v} { $self _configure_relative ./vlanRange -increment $v }
  method _g_./vlanRange/increment {t} { $self _cget_relative ./vlanRange -increment }
  # multiplier 
  method _m_vlan_range_increment {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_increment }
  
  option -vlan_range_inner_increment_step \
    -configuremethod _c_./vlanRange/innerIncrementStep \
    -cgetmethod _g_./vlanRange/innerIncrementStep \
    -readonly false
  method _c_./vlanRange/innerIncrementStep {t v} { $self _configure_relative ./vlanRange -inner_increment_step $v }
  method _g_./vlanRange/innerIncrementStep {t} { $self _cget_relative ./vlanRange -inner_increment_step }
  # multiplier 
  method _m_vlan_range_inner_increment_step {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_inner_increment_step }
  
  option -vlan_range_id_incr_mode \
    -configuremethod _c_./vlanRange/idIncrMode \
    -cgetmethod _g_./vlanRange/idIncrMode \
    -readonly false
  method _c_./vlanRange/idIncrMode {t v} { $self _configure_relative ./vlanRange -id_incr_mode $v }
  method _g_./vlanRange/idIncrMode {t} { $self _cget_relative ./vlanRange -id_incr_mode }
  # multiplier 
  method _m_vlan_range_id_incr_mode {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_id_incr_mode }
  
  option -vlan_range_inner_priority \
    -configuremethod _c_./vlanRange/innerPriority \
    -cgetmethod _g_./vlanRange/innerPriority \
    -readonly false
  method _c_./vlanRange/innerPriority {t v} { $self _configure_relative ./vlanRange -inner_priority $v }
  method _g_./vlanRange/innerPriority {t} { $self _cget_relative ./vlanRange -inner_priority }
  # multiplier 
  method _m_vlan_range_inner_priority {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -vlan_range_inner_priority }
  
  option -vlan_range_vlan_id_info \
    -configuremethod _c_./vlanRange/vlanIdInfo \
    -cgetmethod _g_./vlanRange/vlanIdInfo \
    -readonly false
  method _c_./vlanRange/vlanIdInfo {t v} { $self _configure_relative ./vlanRange -vlan_id_info $v }
  method _g_./vlanRange/vlanIdInfo {t} { $self _cget_relative ./vlanRange -vlan_id_info }
  option -mac_range_object_id \
    -configuremethod _c_./macRange/objectId \
    -cgetmethod _g_./macRange/objectId \
    -readonly false
  method _c_./macRange/objectId {t v} { $self _configure_relative ./macRange -object_id $v }
  method _g_./macRange/objectId {t} { $self _cget_relative ./macRange -object_id }
  # multiplier 
  method _m_mac_range_object_id {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -mac_range_object_id }
  
  option -mac_range_increment_by \
    -configuremethod _c_./macRange/incrementBy \
    -cgetmethod _g_./macRange/incrementBy \
    -readonly false
  method _c_./macRange/incrementBy {t v} { $self _configure_relative ./macRange -increment_by $v }
  method _g_./macRange/incrementBy {t} { $self _cget_relative ./macRange -increment_by }
  # multiplier 
  method _m_mac_range_increment_by {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -mac_range_increment_by }
  
  option -mac_range_name \
    -configuremethod _c_./macRange/name \
    -cgetmethod _g_./macRange/name \
    -readonly false
  method _c_./macRange/name {t v} { $self _configure_relative ./macRange -name $v }
  method _g_./macRange/name {t} { $self _cget_relative ./macRange -name }
  # multiplier 
  method _m_mac_range_name {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -mac_range_name }
  
  option -mac_range_count \
    -configuremethod _c_./macRange/count \
    -cgetmethod _g_./macRange/count \
    -readonly false
  method _c_./macRange/count {t v} { $self _configure_relative ./macRange -count $v }
  method _g_./macRange/count {t} { $self _cget_relative ./macRange -count }
  # multiplier 
  method _m_mac_range_count {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -mac_range_count }
  
  option -mac_range_mac \
    -configuremethod _c_./macRange/mac \
    -cgetmethod _g_./macRange/mac \
    -readonly false
  method _c_./macRange/mac {t v} { $self _configure_relative ./macRange -mac $v }
  method _g_./macRange/mac {t} { $self _cget_relative ./macRange -mac }
  # multiplier 
  method _m_mac_range_mac {mog_args m n other_args} {  $Shell _m_kString  $self $mog_args $m $n $other_args -mac_range_mac }
  
  option -mac_range_mtu \
    -configuremethod _c_./macRange/mtu \
    -cgetmethod _g_./macRange/mtu \
    -readonly false
  method _c_./macRange/mtu {t v} { $self _configure_relative ./macRange -mtu $v }
  method _g_./macRange/mtu {t} { $self _cget_relative ./macRange -mtu }
  # multiplier 
  method _m_mac_range_mtu {mog_args m n other_args} {  $Shell _m_kInteger64  $self $mog_args $m $n $other_args -mac_range_mtu }
  
  option -mac_range_enabled \
    -configuremethod _c_./macRange/enabled \
    -cgetmethod _g_./macRange/enabled \
    -readonly false
  method _c_./macRange/enabled {t v} { $self _configure_relative ./macRange -enabled $v }
  method _g_./macRange/enabled {t} { $self _cget_relative ./macRange -enabled }
  # End options that are mapped to ixn properties
  #------------------------------------------------------
  
  option -shell -default "" -readonly true
  
  #
  # constructor/destructor section
  #
  delegate option * to CustomOptionHandler
  constructor {args} {
      $self configurelist $args
      catch {$self _post_constructor} err
      set result ""
      set failed [catch {$self _construct_custom_option_handler} res]
      if {!$failed} {
          set CustomOptionHandler $res
      }
      if {$failed} {
          set msg "warning: _construct_custom_options_handler error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
      set failed [catch {
          set MultiplierOptionGroups [concat  [$self _custom_multiplier_option_groups]  $MultiplierOptionGroups]
      } err]
      if {$failed} {
          set msg "warning: _custom_multiplier_option_groups error: "
          append msg "$res:\n$::errorInfo" 
          puts stderr $msg
      }
  }
  destructor {
      set failed [catch {$self _pre_destructor} err]
      if {$failed} {
          puts stderr  "warning: _pre_destructor error: $err:\n$::errorInfo"
      }
      set failed [catch {$self _destroy_clan} err]
      if {$failed} {
          puts stderr  "----\nwarning: _destroy_clan error: $err:\n$::errorInfo\n---"
      }
      # if it's the dummy custom option handler
      # leave it alone it's shared by everyone..
      if {$CustomOptionHandler !=  "::ixia::hag::ixn::types::nooptionhandler"} {
          set failed [catch {$CustomOptionHandler destroy} err]
          if {$failed} {
              puts stderr  "warning: _destroy_clan err: $err:\n$::errorInfo"
          }
      }
  }
  method _configlist {args} {
      if {[llength $args] == 1} {set args [lindex $args 0]}
      set last_n "?"
      foreach {t v} $args {
          if {($last_n != "?") && [info exists Opt2IxnName($t)]} {
              set n [file dirname $Opt2IxnName($t)]
              if {$n != $last_n} {
                  # puts stderr "ZZZZZZ $n != $last_n, commit"
                  $Shell _ixn_eval ixNet commit
                  set last_n $n
              }
          } elseif {[info exists Opt2IxnName($t)]} {
              set last_n [file dirname $Opt2IxnName($t)]
          }
          $self configure $t $v
      }
  }
  # Intended to be overrideable
  method _post_constructor {} {
      # place holder to allow for interposing of code after
      # construction takes place
  }
  # Intended to be overrideable
  method _pre_destructor {} {
      # place holder to allow for interposing of code before
      # destruction of object takes place
  }
  # Intended to be overrideable
  method _alterations_to_option_defaults {} {
      # place holder to allow for option defaults different from
      # ixn meta schema
      return {}
  }
  # Intended to be overrideable
  method _custom_multiplier_option_groups {} {
      return {}
  }
  variable CustomOptionHandler ""
  # Intended to be overrideable
  method _construct_custom_option_handler {} {
      return ::ixia::hag::ixn::types::nooptionhandler
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_keyed_list_add {
   inst port_str bank_tag bank_name alias_array_N rows_array_N rval_N
  } {
      upvar 1 $alias_array_N alias_array
      upvar 1 $rows_array_N rows_array
      upvar 1 $rval_N rval
      foreach {n} [array names rows_array {[0-9]*,*}] {
          set v $rows_array($n)
          set nn [join [lrange [split $n ","] 1 end] ","]
          # if an alias is not defined, generate one
          # map dashes spaces dots. etc.. to underscore
          # and lower case everything
          if {![info exists alias_array($nn)]} {
              set alias_array($nn) [string map  { "-" "_" " " "_" "." "_" "/" "_"}  [string tolower $nn]]
          }
          set alias $alias_array($nn)
          keylset rval ${port_str}.aggregate.${bank_tag}.${alias} $v
      }
  }
  
  # Intended to be overrideable
  typemethod _aggregate_stat_decl {inst} {
      puts stderr "*** Note! no _aggregate_stat_decl override declared for:\n***\t$inst"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $inst"
      return {}
  }
  typemethod _stat_doc_decl {} {
      puts stderr "*** Note! no _stat_doc_decl override declared for:\n***\t$type"
      puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
      return {}   
  }
  typemethod _gen_config_arg_callback {param_name param_desc_ref} {
      #puts stderr "*** Note! no _gen_config_arg_callback override declared for:\n***\t$type"
      #puts stderr "*** check the tailor_XXX.tcl file associated w/ $type"
  }
  
  typemethod _aggregate_stats {inst_list} {
      set rval {}
      if {[llength $inst_list] == 0} {
          return -code error "no instances supplied"
      }
  
      set trobj [lindex $inst_list 0]
      #---
      # (Get) list of chassis ip from ixn. this is used to 
      # so we can convert chassis address to chassis number
      # see (Parse) comment below
      #
      set ch_list [$Shell _ixn_chassis_ip_list]
      #---
      foreach {inst} $inst_list {
          set hlt_port_str [$Shell _hlt_port_string_for_inst $inst]
  
          set decl [$type _aggregate_stat_decl $inst]
          #array set statViewBrowserNamesArray $statistic_types
          set statViewBrowserNamesList {}
          foreach { bank_tag bank_name bank_items } $decl {
              if {[string match "#*" $bank_tag]} {
                  continue
              }
              lappend statViewBrowserNamesList $bank_name
          }
  
          # TBD: classic code had this after
          # apparently enabling stats is buggy
          #after 10000
          $Shell _stats_enable_view_list $statViewBrowserNamesList
  
          array set alias_array {};
          array set rows_array {}; unset rows_array
          array set rows_array {}
          foreach {bank_tag bank_name bank_items} $decl {
              set stats_list {};
              unset alias_array; array set alias_array {}
              foreach {t v}  $bank_items {
                  lappend stats_list $t
                  if {[string equal $v "-"]} {
                    set v [string map {" " "_"} [string tolower $t]]
                  }
                  set alias_array($t) $v
              }
              # (re)init stats array to empty;
              unset rows_array; array set rows_array {};
              set row_count [$Shell  _stats_get rows_array $bank_name $stats_list $inst]
              if {1} {
                  $trobj _trace "Got $row_count stat rows"
                  foreach {n} [lsort [array names rows_array]] {
                      $trobj _tr "RRR <$hlt_port_str,$bank_tag,$bank_name>\t$n: $rows_array($n)"
                  }
              }
              $type _aggregate_stat_keyed_list_add  $inst  $hlt_port_str $bank_tag $bank_name  alias_array  rows_array  rval
          }
      } 
      return $rval
  }
  
  
  # Map of hlt option name --> ixnetwork attribute name
  typemethod getOpt2IxnName {} {array get Opt2IxnName}
  typevariable Opt2IxnName -array {
    -esmc_range_object_id ./esmcRange/objectId
    -esmc_range_rate ./esmcRange/rate
    -esmc_range_name ./esmcRange/name
    -esmc_range_ql ./esmcRange/ql
    -esmc_range_wait_id ./esmcRange/waitId
    -esmc_range_enabled ./esmcRange/enabled
    -esmc_range_flag_mode ./esmcRange/flagMode
    -dot1x_range_user_password ./dot1xRange/userPassword
    -dot1x_range_nac_sequence ./dot1xRange/nacSequence
    -dot1x_range_enabled ./dot1xRange/enabled
    -dot1x_range_fast_stateless_resume ./dot1xRange/fastStatelessResume
    -dot1x_range_user_name ./dot1xRange/userName
    -dot1x_range_host_password ./dot1xRange/hostPassword
    -dot1x_range_name ./dot1xRange/name
    -dot1x_range_wait_id ./dot1xRange/waitId
    -dot1x_range_protocol ./dot1xRange/protocol
    -dot1x_range_fast_inner_method ./dot1xRange/fastInnerMethod
    -dot1x_range_object_id ./dot1xRange/objectId
    -dot1x_range_fast_provision_mode ./dot1xRange/fastProvisionMode
    -dot1x_range_host_auth_mode ./dot1xRange/hostAuthMode
    -dot1x_range_host_name ./dot1xRange/hostName
    -dcbx_range_tx_interval ./dcbxRange/txInterval
    -dcbx_range_fast_init_enable ./dcbxRange/fastInitEnable
    -dcbx_range_enabled ./dcbxRange/enabled
    -dcbx_range_chassis_id ./dcbxRange/chassisId
    -dcbx_range_port_id_interface_name ./dcbxRange/portIdInterfaceName
    -dcbx_range_oui ./dcbxRange/oui
    -dcbx_range_dest_mac_address ./dcbxRange/destMacAddress
    -dcbx_range_dcbx_enable ./dcbxRange/dcbxEnable
    -dcbx_range_name ./dcbxRange/name
    -dcbx_range_port_id_mac_address ./dcbxRange/portIdMacAddress
    -dcbx_range_control_tlv_max_version ./dcbxRange/controlTlvMaxVersion
    -dcbx_range_tx_delay ./dcbxRange/txDelay
    -dcbx_range_object_id ./dcbxRange/objectId
    -dcbx_range_dcbx_subtype ./dcbxRange/dcbxSubtype
    -dcbx_range_port_id_sub_type ./dcbxRange/portIdSubType
    -dcbx_range_hold_time ./dcbxRange/holdTime
    -dcbx_range_lldp_tlv ./dcbxRange/lldpTlv
    -dcbx_range_dcbx_tlv_qaz ./dcbxRange/dcbxTlvQaz
    -dcbx_range_dcbx_tlv ./dcbxRange/dcbxTlv
    -vic_client_range_prov_info_tlvs ./vicClientRange/provInfoTlvs
    -vic_client_range_object_id ./vicClientRange/objectId
    -vic_client_range_macs_per_vif ./vicClientRange/macsPerVif
    -vic_client_range_channel_id_start ./vicClientRange/channelIdStart
    -vic_client_range_prov_info_oui ./vicClientRange/provInfoOui
    -vic_client_range_name ./vicClientRange/name
    -vic_client_range_vif_active ./vicClientRange/vifActive
    -vic_client_range_tlv_offset ./vicClientRange/tlvOffset
    -vic_client_range_prov_info_type ./vicClientRange/provInfoType
    -vic_client_range_enabled ./vicClientRange/enabled
    -vic_client_range_channel_id_increment ./vicClientRange/channelIdIncrement
    -ptp_range_over_mac_master_mac_increment_inter_entity ./ptpRangeOverMac/masterMacIncrementInterEntity
    -ptp_range_over_mac_communication_mode ./ptpRangeOverMac/communicationMode
    -ptp_range_over_mac_send_announce_multicast ./ptpRangeOverMac/sendAnnounceMulticast
    -ptp_range_over_mac_follow_up_delay ./ptpRangeOverMac/followUpDelay
    -ptp_range_over_mac_domain ./ptpRangeOverMac/domain
    -ptp_range_over_mac_announce_drop_rate ./ptpRangeOverMac/announceDropRate
    -ptp_range_over_mac_client_ip_increment_by ./ptpRangeOverMac/clientIpIncrementBy
    -ptp_range_over_mac_renewal_invited ./ptpRangeOverMac/renewalInvited
    -ptp_range_over_mac_port_number_increment ./ptpRangeOverMac/portNumberIncrement
    -ptp_range_over_mac_use_clock_identity ./ptpRangeOverMac/useClockIdentity
    -ptp_range_over_mac_priority1 ./ptpRangeOverMac/priority1
    -ptp_range_over_mac_use_alternate_master_flag ./ptpRangeOverMac/useAlternateMasterFlag
    -ptp_range_over_mac_object_id ./ptpRangeOverMac/objectId
    -ptp_range_over_mac_delay_resp_receipt_timeout ./ptpRangeOverMac/delayRespReceiptTimeout
    -ptp_range_over_mac_announce_frequency_traceable ./ptpRangeOverMac/announceFrequencyTraceable
    -ptp_range_over_mac_priority2 ./ptpRangeOverMac/priority2
    -ptp_range_over_mac_announce_current_utc_offset_valid ./ptpRangeOverMac/announceCurrentUtcOffsetValid
    -ptp_range_over_mac_client_mac_address ./ptpRangeOverMac/clientMacAddress
    -ptp_range_over_mac_time_source ./ptpRangeOverMac/timeSource
    -ptp_range_over_mac_steps_removed ./ptpRangeOverMac/stepsRemoved
    -ptp_range_over_mac_clock_class ./ptpRangeOverMac/clockClass
    -ptp_range_over_mac_request_attempts ./ptpRangeOverMac/requestAttempts
    -ptp_range_over_mac_follow_up_bad_crc_rate ./ptpRangeOverMac/followUpBadCrcRate
    -ptp_range_over_mac_delay_response_delay_insertion_rate ./ptpRangeOverMac/delayResponseDelayInsertionRate
    -ptp_range_over_mac_log_sync_interval ./ptpRangeOverMac/logSyncInterval
    -ptp_range_over_mac_master_count ./ptpRangeOverMac/masterCount
    -ptp_range_over_mac_residence_time ./ptpRangeOverMac/residenceTime
    -ptp_range_over_mac_signal_interval ./ptpRangeOverMac/signalInterval
    -ptp_range_over_mac_delay_mechanism ./ptpRangeOverMac/delayMechanism
    -ptp_range_over_mac_strict_grant ./ptpRangeOverMac/strictGrant
    -ptp_range_over_mac_sync_drop_rate ./ptpRangeOverMac/syncDropRate
    -ptp_range_over_mac_drop_signal_req_sync ./ptpRangeOverMac/dropSignalReqSync
    -ptp_range_over_mac_clock_increment ./ptpRangeOverMac/clockIncrement
    -ptp_range_over_mac_announce_ptp_timescale ./ptpRangeOverMac/announcePtpTimescale
    -ptp_range_over_mac_signal_unicast_handling ./ptpRangeOverMac/signalUnicastHandling
    -ptp_range_over_mac_enabled ./ptpRangeOverMac/enabled
    -ptp_range_over_mac_timestamp_offset ./ptpRangeOverMac/timestampOffset
    -ptp_range_over_mac_master_ip_increment_by ./ptpRangeOverMac/masterIpIncrementBy
    -ptp_range_over_mac_request_interval ./ptpRangeOverMac/requestInterval
    -ptp_range_over_mac_ip_tos ./ptpRangeOverMac/ipTos
    -ptp_range_over_mac_request_holddown ./ptpRangeOverMac/requestHolddown
    -ptp_range_over_mac_client_mac_increment_by ./ptpRangeOverMac/clientMacIncrementBy
    -ptp_range_over_mac_name ./ptpRangeOverMac/name
    -ptp_range_over_mac_drop_signal_req_announce ./ptpRangeOverMac/dropSignalReqAnnounce
    -ptp_range_over_mac_master_ip_address ./ptpRangeOverMac/masterIpAddress
    -ptp_range_over_mac_first_clock ./ptpRangeOverMac/firstClock
    -ptp_range_over_mac_master_mac_increment_by ./ptpRangeOverMac/masterMacIncrementBy
    -ptp_range_over_mac_send_cancel_tlv ./ptpRangeOverMac/sendCancelTlv
    -ptp_range_over_mac_port_number ./ptpRangeOverMac/portNumber
    -ptp_range_over_mac_client_ip_address ./ptpRangeOverMac/clientIpAddress
    -ptp_range_over_mac_announce_leap59 ./ptpRangeOverMac/announceLeap59
    -ptp_range_over_mac_send_announce_tlv ./ptpRangeOverMac/sendAnnounceTlv
    -ptp_range_over_mac_sync_receipt_timeout ./ptpRangeOverMac/syncReceiptTimeout
    -ptp_range_over_mac_announce_leap61 ./ptpRangeOverMac/announceLeap61
    -ptp_range_over_mac_grant_delay_resp_duration_interval ./ptpRangeOverMac/grantDelayRespDurationInterval
    -ptp_range_over_mac_timestamp_offset_variation ./ptpRangeOverMac/timestampOffsetVariation
    -ptp_range_over_mac_follow_up_drop_rate ./ptpRangeOverMac/followUpDropRate
    -ptp_range_over_mac_master_mac_address ./ptpRangeOverMac/masterMacAddress
    -ptp_range_over_mac_drop_signal_req_delay_resp ./ptpRangeOverMac/dropSignalReqDelayResp
    -ptp_range_over_mac_grant_sync_duration_interval ./ptpRangeOverMac/grantSyncDurationInterval
    -ptp_range_over_mac_learn_port_id ./ptpRangeOverMac/learnPortId
    -ptp_range_over_mac_delay_response_delay ./ptpRangeOverMac/delayResponseDelay
    -ptp_range_over_mac_grant_unicast_duration_interval ./ptpRangeOverMac/grantUnicastDurationInterval
    -ptp_range_over_mac_follow_up_delay_insertion_rate ./ptpRangeOverMac/followUpDelayInsertionRate
    -ptp_range_over_mac_log_delay_req_interval ./ptpRangeOverMac/logDelayReqInterval
    -ptp_range_over_mac_clock_accuracy ./ptpRangeOverMac/clockAccuracy
    -ptp_range_over_mac_client_count ./ptpRangeOverMac/clientCount
    -ptp_range_over_mac_announce_time_traceable ./ptpRangeOverMac/announceTimeTraceable
    -ptp_range_over_mac_step_mode ./ptpRangeOverMac/stepMode
    -ptp_range_over_mac_master_ip_increment_inter_entity ./ptpRangeOverMac/masterIpIncrementInterEntity
    -ptp_range_over_mac_delay_resp_drop_rate ./ptpRangeOverMac/delayRespDropRate
    -ptp_range_over_mac_announce_receipt_timeout ./ptpRangeOverMac/announceReceiptTimeout
    -ptp_range_over_mac_rx_calibration ./ptpRangeOverMac/rxCalibration
    -ptp_range_over_mac_tx_calibration ./ptpRangeOverMac/txCalibration
    -ptp_range_over_mac_log_announce_interval ./ptpRangeOverMac/logAnnounceInterval
    -vlan_range_inner_first_id ./vlanRange/innerFirstId
    -vlan_range_inner_increment ./vlanRange/innerIncrement
    -vlan_range_enabled ./vlanRange/enabled
    -vlan_range_unique_count ./vlanRange/uniqueCount
    -vlan_range_name ./vlanRange/name
    -vlan_range_increment_step ./vlanRange/incrementStep
    -vlan_range_tpid ./vlanRange/tpid
    -vlan_range_priority ./vlanRange/priority
    -vlan_range_inner_enable ./vlanRange/innerEnable
    -vlan_range_object_id ./vlanRange/objectId
    -vlan_range_inner_unique_count ./vlanRange/innerUniqueCount
    -vlan_range_inner_tpid ./vlanRange/innerTpid
    -vlan_range_first_id ./vlanRange/firstId
    -vlan_range_increment ./vlanRange/increment
    -vlan_range_inner_increment_step ./vlanRange/innerIncrementStep
    -vlan_range_id_incr_mode ./vlanRange/idIncrMode
    -vlan_range_inner_priority ./vlanRange/innerPriority
    -vlan_range_vlan_id_info ./vlanRange/vlanIdInfo
    -mac_range_object_id ./macRange/objectId
    -mac_range_increment_by ./macRange/incrementBy
    -mac_range_name ./macRange/name
    -mac_range_count ./macRange/count
    -mac_range_mac ./macRange/mac
    -mac_range_mtu ./macRange/mtu
    -mac_range_enabled ./macRange/enabled
  }
  #
  variable MultiplierOptionGroups {
    _m_esmc_range_object_id {-esmc_range_object_id_format -esmc_range_object_id_base -esmc_range_object_id_incr}
    _m_esmc_range_rate {-esmc_range_rate_base -esmc_range_rate_incr}
    _m_esmc_range_name {-esmc_range_name_format -esmc_range_name_base -esmc_range_name_incr}
    _m_esmc_range_ql {-esmc_range_ql_format -esmc_range_ql_base -esmc_range_ql_incr}
    _m_esmc_range_flag_mode {-esmc_range_flag_mode_format -esmc_range_flag_mode_base -esmc_range_flag_mode_incr}
    _m_dot1x_range_user_password {-dot1x_range_user_password_format -dot1x_range_user_password_base -dot1x_range_user_password_incr}
    _m_dot1x_range_fast_stateless_resume {-dot1x_range_fast_stateless_resume_format -dot1x_range_fast_stateless_resume_base -dot1x_range_fast_stateless_resume_incr}
    _m_dot1x_range_user_name {-dot1x_range_user_name_format -dot1x_range_user_name_base -dot1x_range_user_name_incr}
    _m_dot1x_range_host_password {-dot1x_range_host_password_format -dot1x_range_host_password_base -dot1x_range_host_password_incr}
    _m_dot1x_range_name {-dot1x_range_name_format -dot1x_range_name_base -dot1x_range_name_incr}
    _m_dot1x_range_protocol {-dot1x_range_protocol_format -dot1x_range_protocol_base -dot1x_range_protocol_incr}
    _m_dot1x_range_fast_inner_method {-dot1x_range_fast_inner_method_format -dot1x_range_fast_inner_method_base -dot1x_range_fast_inner_method_incr}
    _m_dot1x_range_object_id {-dot1x_range_object_id_format -dot1x_range_object_id_base -dot1x_range_object_id_incr}
    _m_dot1x_range_fast_provision_mode {-dot1x_range_fast_provision_mode_format -dot1x_range_fast_provision_mode_base -dot1x_range_fast_provision_mode_incr}
    _m_dot1x_range_host_auth_mode {-dot1x_range_host_auth_mode_format -dot1x_range_host_auth_mode_base -dot1x_range_host_auth_mode_incr}
    _m_dot1x_range_host_name {-dot1x_range_host_name_format -dot1x_range_host_name_base -dot1x_range_host_name_incr}
    _m_dcbx_range_tx_interval {-dcbx_range_tx_interval_base -dcbx_range_tx_interval_incr}
    _m_dcbx_range_chassis_id {-dcbx_range_chassis_id_format -dcbx_range_chassis_id_base -dcbx_range_chassis_id_incr}
    _m_dcbx_range_port_id_interface_name {-dcbx_range_port_id_interface_name_format -dcbx_range_port_id_interface_name_base -dcbx_range_port_id_interface_name_incr}
    _m_dcbx_range_oui {-dcbx_range_oui_format -dcbx_range_oui_base -dcbx_range_oui_incr}
    _m_dcbx_range_dest_mac_address {-dcbx_range_dest_mac_address_format -dcbx_range_dest_mac_address_base -dcbx_range_dest_mac_address_incr}
    _m_dcbx_range_name {-dcbx_range_name_format -dcbx_range_name_base -dcbx_range_name_incr}
    _m_dcbx_range_port_id_mac_address {-dcbx_range_port_id_mac_address_format -dcbx_range_port_id_mac_address_base -dcbx_range_port_id_mac_address_incr}
    _m_dcbx_range_control_tlv_max_version {-dcbx_range_control_tlv_max_version_base -dcbx_range_control_tlv_max_version_incr}
    _m_dcbx_range_tx_delay {-dcbx_range_tx_delay_base -dcbx_range_tx_delay_incr}
    _m_dcbx_range_object_id {-dcbx_range_object_id_format -dcbx_range_object_id_base -dcbx_range_object_id_incr}
    _m_dcbx_range_dcbx_subtype {-dcbx_range_dcbx_subtype_base -dcbx_range_dcbx_subtype_incr}
    _m_dcbx_range_port_id_sub_type {-dcbx_range_port_id_sub_type_base -dcbx_range_port_id_sub_type_incr}
    _m_dcbx_range_hold_time {-dcbx_range_hold_time_base -dcbx_range_hold_time_incr}
    _m_vic_client_range_object_id {-vic_client_range_object_id_format -vic_client_range_object_id_base -vic_client_range_object_id_incr}
    _m_vic_client_range_macs_per_vif {-vic_client_range_macs_per_vif_base -vic_client_range_macs_per_vif_incr}
    _m_vic_client_range_channel_id_start {-vic_client_range_channel_id_start_base -vic_client_range_channel_id_start_incr}
    _m_vic_client_range_prov_info_oui {-vic_client_range_prov_info_oui_format -vic_client_range_prov_info_oui_base -vic_client_range_prov_info_oui_incr}
    _m_vic_client_range_name {-vic_client_range_name_format -vic_client_range_name_base -vic_client_range_name_incr}
    _m_vic_client_range_tlv_offset {-vic_client_range_tlv_offset_base -vic_client_range_tlv_offset_incr}
    _m_vic_client_range_prov_info_type {-vic_client_range_prov_info_type_base -vic_client_range_prov_info_type_incr}
    _m_vic_client_range_channel_id_increment {-vic_client_range_channel_id_increment_base -vic_client_range_channel_id_increment_incr}
    _m_ptp_range_over_mac_master_mac_increment_inter_entity {-ptp_range_over_mac_master_mac_increment_inter_entity_format -ptp_range_over_mac_master_mac_increment_inter_entity_base -ptp_range_over_mac_master_mac_increment_inter_entity_incr}
    _m_ptp_range_over_mac_communication_mode {-ptp_range_over_mac_communication_mode_format -ptp_range_over_mac_communication_mode_base -ptp_range_over_mac_communication_mode_incr}
    _m_ptp_range_over_mac_follow_up_delay {-ptp_range_over_mac_follow_up_delay_base -ptp_range_over_mac_follow_up_delay_incr}
    _m_ptp_range_over_mac_domain {-ptp_range_over_mac_domain_base -ptp_range_over_mac_domain_incr}
    _m_ptp_range_over_mac_announce_drop_rate {-ptp_range_over_mac_announce_drop_rate_base -ptp_range_over_mac_announce_drop_rate_incr}
    _m_ptp_range_over_mac_client_ip_increment_by {-ptp_range_over_mac_client_ip_increment_by_format -ptp_range_over_mac_client_ip_increment_by_base -ptp_range_over_mac_client_ip_increment_by_incr}
    _m_ptp_range_over_mac_port_number_increment {-ptp_range_over_mac_port_number_increment_base -ptp_range_over_mac_port_number_increment_incr}
    _m_ptp_range_over_mac_priority1 {-ptp_range_over_mac_priority1_base -ptp_range_over_mac_priority1_incr}
    _m_ptp_range_over_mac_object_id {-ptp_range_over_mac_object_id_format -ptp_range_over_mac_object_id_base -ptp_range_over_mac_object_id_incr}
    _m_ptp_range_over_mac_delay_resp_receipt_timeout {-ptp_range_over_mac_delay_resp_receipt_timeout_base -ptp_range_over_mac_delay_resp_receipt_timeout_incr}
    _m_ptp_range_over_mac_priority2 {-ptp_range_over_mac_priority2_base -ptp_range_over_mac_priority2_incr}
    _m_ptp_range_over_mac_client_mac_address {-ptp_range_over_mac_client_mac_address_format -ptp_range_over_mac_client_mac_address_base -ptp_range_over_mac_client_mac_address_incr}
    _m_ptp_range_over_mac_time_source {-ptp_range_over_mac_time_source_format -ptp_range_over_mac_time_source_base -ptp_range_over_mac_time_source_incr}
    _m_ptp_range_over_mac_steps_removed {-ptp_range_over_mac_steps_removed_base -ptp_range_over_mac_steps_removed_incr}
    _m_ptp_range_over_mac_clock_class {-ptp_range_over_mac_clock_class_base -ptp_range_over_mac_clock_class_incr}
    _m_ptp_range_over_mac_request_attempts {-ptp_range_over_mac_request_attempts_base -ptp_range_over_mac_request_attempts_incr}
    _m_ptp_range_over_mac_follow_up_bad_crc_rate {-ptp_range_over_mac_follow_up_bad_crc_rate_base -ptp_range_over_mac_follow_up_bad_crc_rate_incr}
    _m_ptp_range_over_mac_delay_response_delay_insertion_rate {-ptp_range_over_mac_delay_response_delay_insertion_rate_base -ptp_range_over_mac_delay_response_delay_insertion_rate_incr}
    _m_ptp_range_over_mac_log_sync_interval {-ptp_range_over_mac_log_sync_interval_base -ptp_range_over_mac_log_sync_interval_incr}
    _m_ptp_range_over_mac_master_count {-ptp_range_over_mac_master_count_base -ptp_range_over_mac_master_count_incr}
    _m_ptp_range_over_mac_residence_time {-ptp_range_over_mac_residence_time_base -ptp_range_over_mac_residence_time_incr}
    _m_ptp_range_over_mac_signal_interval {-ptp_range_over_mac_signal_interval_base -ptp_range_over_mac_signal_interval_incr}
    _m_ptp_range_over_mac_delay_mechanism {-ptp_range_over_mac_delay_mechanism_format -ptp_range_over_mac_delay_mechanism_base -ptp_range_over_mac_delay_mechanism_incr}
    _m_ptp_range_over_mac_sync_drop_rate {-ptp_range_over_mac_sync_drop_rate_base -ptp_range_over_mac_sync_drop_rate_incr}
    _m_ptp_range_over_mac_clock_increment {-ptp_range_over_mac_clock_increment_format -ptp_range_over_mac_clock_increment_base -ptp_range_over_mac_clock_increment_incr}
    _m_ptp_range_over_mac_signal_unicast_handling {-ptp_range_over_mac_signal_unicast_handling_format -ptp_range_over_mac_signal_unicast_handling_base -ptp_range_over_mac_signal_unicast_handling_incr}
    _m_ptp_range_over_mac_timestamp_offset {-ptp_range_over_mac_timestamp_offset_base -ptp_range_over_mac_timestamp_offset_incr}
    _m_ptp_range_over_mac_master_ip_increment_by {-ptp_range_over_mac_master_ip_increment_by_format -ptp_range_over_mac_master_ip_increment_by_base -ptp_range_over_mac_master_ip_increment_by_incr}
    _m_ptp_range_over_mac_request_interval {-ptp_range_over_mac_request_interval_base -ptp_range_over_mac_request_interval_incr}
    _m_ptp_range_over_mac_ip_tos {-ptp_range_over_mac_ip_tos_base -ptp_range_over_mac_ip_tos_incr}
    _m_ptp_range_over_mac_request_holddown {-ptp_range_over_mac_request_holddown_base -ptp_range_over_mac_request_holddown_incr}
    _m_ptp_range_over_mac_client_mac_increment_by {-ptp_range_over_mac_client_mac_increment_by_format -ptp_range_over_mac_client_mac_increment_by_base -ptp_range_over_mac_client_mac_increment_by_incr}
    _m_ptp_range_over_mac_name {-ptp_range_over_mac_name_format -ptp_range_over_mac_name_base -ptp_range_over_mac_name_incr}
    _m_ptp_range_over_mac_master_ip_address {-ptp_range_over_mac_master_ip_address_format -ptp_range_over_mac_master_ip_address_base -ptp_range_over_mac_master_ip_address_incr}
    _m_ptp_range_over_mac_first_clock {-ptp_range_over_mac_first_clock_format -ptp_range_over_mac_first_clock_base -ptp_range_over_mac_first_clock_incr}
    _m_ptp_range_over_mac_master_mac_increment_by {-ptp_range_over_mac_master_mac_increment_by_format -ptp_range_over_mac_master_mac_increment_by_base -ptp_range_over_mac_master_mac_increment_by_incr}
    _m_ptp_range_over_mac_port_number {-ptp_range_over_mac_port_number_base -ptp_range_over_mac_port_number_incr}
    _m_ptp_range_over_mac_client_ip_address {-ptp_range_over_mac_client_ip_address_format -ptp_range_over_mac_client_ip_address_base -ptp_range_over_mac_client_ip_address_incr}
    _m_ptp_range_over_mac_sync_receipt_timeout {-ptp_range_over_mac_sync_receipt_timeout_base -ptp_range_over_mac_sync_receipt_timeout_incr}
    _m_ptp_range_over_mac_grant_delay_resp_duration_interval {-ptp_range_over_mac_grant_delay_resp_duration_interval_base -ptp_range_over_mac_grant_delay_resp_duration_interval_incr}
    _m_ptp_range_over_mac_timestamp_offset_variation {-ptp_range_over_mac_timestamp_offset_variation_base -ptp_range_over_mac_timestamp_offset_variation_incr}
    _m_ptp_range_over_mac_follow_up_drop_rate {-ptp_range_over_mac_follow_up_drop_rate_base -ptp_range_over_mac_follow_up_drop_rate_incr}
    _m_ptp_range_over_mac_master_mac_address {-ptp_range_over_mac_master_mac_address_format -ptp_range_over_mac_master_mac_address_base -ptp_range_over_mac_master_mac_address_incr}
    _m_ptp_range_over_mac_grant_sync_duration_interval {-ptp_range_over_mac_grant_sync_duration_interval_base -ptp_range_over_mac_grant_sync_duration_interval_incr}
    _m_ptp_range_over_mac_delay_response_delay {-ptp_range_over_mac_delay_response_delay_base -ptp_range_over_mac_delay_response_delay_incr}
    _m_ptp_range_over_mac_grant_unicast_duration_interval {-ptp_range_over_mac_grant_unicast_duration_interval_base -ptp_range_over_mac_grant_unicast_duration_interval_incr}
    _m_ptp_range_over_mac_follow_up_delay_insertion_rate {-ptp_range_over_mac_follow_up_delay_insertion_rate_base -ptp_range_over_mac_follow_up_delay_insertion_rate_incr}
    _m_ptp_range_over_mac_log_delay_req_interval {-ptp_range_over_mac_log_delay_req_interval_base -ptp_range_over_mac_log_delay_req_interval_incr}
    _m_ptp_range_over_mac_clock_accuracy {-ptp_range_over_mac_clock_accuracy_format -ptp_range_over_mac_clock_accuracy_base -ptp_range_over_mac_clock_accuracy_incr}
    _m_ptp_range_over_mac_client_count {-ptp_range_over_mac_client_count_base -ptp_range_over_mac_client_count_incr}
    _m_ptp_range_over_mac_step_mode {-ptp_range_over_mac_step_mode_format -ptp_range_over_mac_step_mode_base -ptp_range_over_mac_step_mode_incr}
    _m_ptp_range_over_mac_master_ip_increment_inter_entity {-ptp_range_over_mac_master_ip_increment_inter_entity_format -ptp_range_over_mac_master_ip_increment_inter_entity_base -ptp_range_over_mac_master_ip_increment_inter_entity_incr}
    _m_ptp_range_over_mac_delay_resp_drop_rate {-ptp_range_over_mac_delay_resp_drop_rate_base -ptp_range_over_mac_delay_resp_drop_rate_incr}
    _m_ptp_range_over_mac_announce_receipt_timeout {-ptp_range_over_mac_announce_receipt_timeout_base -ptp_range_over_mac_announce_receipt_timeout_incr}
    _m_ptp_range_over_mac_rx_calibration {-ptp_range_over_mac_rx_calibration_base -ptp_range_over_mac_rx_calibration_incr}
    _m_ptp_range_over_mac_tx_calibration {-ptp_range_over_mac_tx_calibration_base -ptp_range_over_mac_tx_calibration_incr}
    _m_ptp_range_over_mac_log_announce_interval {-ptp_range_over_mac_log_announce_interval_base -ptp_range_over_mac_log_announce_interval_incr}
    _m_vlan_range_inner_first_id {-vlan_range_inner_first_id_base -vlan_range_inner_first_id_incr}
    _m_vlan_range_inner_increment {-vlan_range_inner_increment_base -vlan_range_inner_increment_incr}
    _m_vlan_range_unique_count {-vlan_range_unique_count_base -vlan_range_unique_count_incr}
    _m_vlan_range_name {-vlan_range_name_format -vlan_range_name_base -vlan_range_name_incr}
    _m_vlan_range_increment_step {-vlan_range_increment_step_base -vlan_range_increment_step_incr}
    _m_vlan_range_tpid {-vlan_range_tpid_format -vlan_range_tpid_base -vlan_range_tpid_incr}
    _m_vlan_range_priority {-vlan_range_priority_base -vlan_range_priority_incr}
    _m_vlan_range_object_id {-vlan_range_object_id_format -vlan_range_object_id_base -vlan_range_object_id_incr}
    _m_vlan_range_inner_unique_count {-vlan_range_inner_unique_count_base -vlan_range_inner_unique_count_incr}
    _m_vlan_range_inner_tpid {-vlan_range_inner_tpid_format -vlan_range_inner_tpid_base -vlan_range_inner_tpid_incr}
    _m_vlan_range_first_id {-vlan_range_first_id_base -vlan_range_first_id_incr}
    _m_vlan_range_increment {-vlan_range_increment_base -vlan_range_increment_incr}
    _m_vlan_range_inner_increment_step {-vlan_range_inner_increment_step_base -vlan_range_inner_increment_step_incr}
    _m_vlan_range_id_incr_mode {-vlan_range_id_incr_mode_base -vlan_range_id_incr_mode_incr}
    _m_vlan_range_inner_priority {-vlan_range_inner_priority_base -vlan_range_inner_priority_incr}
    _m_mac_range_object_id {-mac_range_object_id_format -mac_range_object_id_base -mac_range_object_id_incr}
    _m_mac_range_increment_by {-mac_range_increment_by_format -mac_range_increment_by_base -mac_range_increment_by_incr}
    _m_mac_range_name {-mac_range_name_format -mac_range_name_base -mac_range_name_incr}
    _m_mac_range_count {-mac_range_count_base -mac_range_count_incr}
    _m_mac_range_mac {-mac_range_mac_format -mac_range_mac_base -mac_range_mac_incr}
    _m_mac_range_mtu {-mac_range_mtu_base -mac_range_mtu_incr}
  }
}

#@ end of ancestors for ::hag::ixnmeta::/vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange

#
# Source in an optional tailor file that allows
# customization for the generated snit objects
#
set file_found 0
set dir [file normalize [file dirname [info script]]]
if {[file exists [set dir]/tailor_dcbxRange.tcl]} {
    set fn [set dir]/tailor_dcbxRange.tcl
    uplevel #0 [list namespace eval :: [list source [set fn]]]
    set file_found 1
} elseif {[file exists [set dir]/../tailor_dcbxRange.tcl]} {
    set fn [set dir]/../tailor_dcbxRange.tcl
    uplevel #0 [list namespace eval :: [list source [set fn]]]
    set file_found 1
}
# if -input-tailor-file-mandatory
if 1 { 
    if {![set file_found]} {
      return -code error  "Could not find required tailorfile 'tailor_dcbxRange.tcl'"
    }
}

#-------------------------------------------------------------
# Generated by the hag on 
#     Fri Aug 07 13:36:45 PDT 2020
#-------------------------------------------------------------
# package requires, etc.
package require snit
#-------------------------------------------------------------

if {[llength [info commands ::ixia::dcbxrange]]} {
    rename ::ixia::dcbxrange ""
}
::ixia::hag::ixn::types::shell ::ixia::dcbxrange  -config-multiplier-option-groups 1  -config-typepathways  [list /vport/protocolStack/ethernet/dcbxEndpoint/range/dcbxRange]
#
# Shell level commands
# - XXX_config
# - XXX_control
# - XXX_stats
#

proc ::ixia::dcbxrange_config {args} {
  set procName [lindex [info level [info level]] 0]
  ::ixia::logHltapiCommand $procName $args
  ::ixia::utrackerLog $procName $args
  if {$::ixia::hag::ixn::Opts(keyedListReturnValues)} {
    set fail [catch  [concat ::ixia::dcbxrange config [set args]] r]
    if {$fail} {
      return [list [list status 0] [list log $r\n$::errorInfo]]
    } else {
      return [list [list status 1] [list handles $r] [list log ""]]
    }
  } else {
    eval [concat {::ixia::dcbxrange config} [set args]]
  }
}

proc ::ixia::dcbxrange_control {args} {
  set procName [lindex [info level [info level]] 0]
  ::ixia::logHltapiCommand $procName $args
  ::ixia::utrackerLog $procName $args
  if {$::ixia::hag::ixn::Opts(keyedListReturnValues)} {
    set fail [catch  [concat ::ixia::dcbxrange control [set args]] r]
    if {$fail} {
      return [list [list status 0] [list log $r\n$::errorInfo]]
    } else {
      return [list [list status 1] [list inner_results $r] [list log ""]]
    }
  } else {
    eval [concat {::ixia::dcbxrange config} [set args]]
  }
}

proc ::ixia::dcbxrange_stats {args} {
  set procName [lindex [info level [info level]] 0]
  ::ixia::logHltapiCommand $procName $args
  ::ixia::utrackerLog $procName $args
  if {$::ixia::hag::ixn::Opts(keyedListReturnValues)} {
    set fail  [catch [concat {::ixia::dcbxrange stats} [set args]] r]
    if {$fail} {
      return [list [list status 0] [list log $r\n$::errorInfo]]
    } else {
      return [concat  [list [list status 1] [list log ""]]  $r  ]
    }
  } else {
    eval [concat {::ixia::dcbxrange stats} [set args]]
  }
}

